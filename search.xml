<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Django 源码阅读：url解析]]></title>
      <url>%2F2019%2F03%2F01%2F2019030101%2F</url>
      <content type="text"><![CDATA[一、写在前面继上一篇博文，进一步分析Django URL解析过程。通过网上博客的学习以及对于源码阅读所做笔记。 邮箱地址：jpzhang.ht@gmail.com个人博客：https://jianpengzhang.github.io/CSDN博客：http://blog.csdn.net/u011521019 ￼# 二、写在前面上一篇博文，django.core.servers.basehttp.py run()函数，服务启动最后的动作是httpd.serve_forever，调用的是socketserver.BaseServer.serve_forever方法。该方法采用了selector网络模型进行等待数据。启动服务后服务器进入一个无限循环的状态，poll_interval用来设置循环间隔时间,默认为0.5秒。在这里先简单分析下Python SocketServer.py 源码，上篇博文中这块的介绍没有好好的梳理。在这里进行补充下。/usr/lib/python2.7/SocketServer.py:BaseServer.serve_forever()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class BaseServer: timeout = None def __init__(self, server_address, RequestHandlerClass): # 初始化,传入构建一个Socket服务器所必需的address以及每个请求到达时的处理类 &quot;&quot;&quot;Constructor. May be extended, do not override.&quot;&quot;&quot; self.server_address = server_address # RequestHandlerClass 注册 handle 函数，在finish_request 中实例化，调用用户定义的 handle 函数 self.RequestHandlerClass = RequestHandlerClass self.__is_shut_down = threading.Event() self.__shutdown_request = False def server_activate(self): &quot;&quot;&quot;Called by constructor to activate the server. May be overridden. 服务器激活，由构造函数调用以激活服务器。可能被重写。 &quot;&quot;&quot; pass # 装饰器函数，重新启动被eintr中断的系统调用 def _eintr_retry(func, *args): &quot;&quot;&quot;restart a system call interrupted by EINTR&quot;&quot;&quot; while True: try: return func(*args) except (OSError, select.error) as e: if e.args[0] != errno.EINTR: raise def serve_forever(self, poll_interval=0.5): &quot;&quot;&quot;Handle one request at a time until shutdown. Polls for shutdown every poll_interval seconds. Ignores self.timeout. If you need to do periodic tasks, do them in another thread. &quot;&quot;&quot; self.__is_shut_down.clear() try: while not self.__shutdown_request: # XXX: Consider using another file descriptor or # connecting to the socket to wake this up instead of # polling. Polling reduces our responsiveness to a # shutdown request and wastes cpu at all other times. # 调用 select 监视请求，处理 EINTR 异常 r, w, e = _eintr_retry(select.select, [self], [], [], poll_interval) if self in r: # 有请求进来 self._handle_request_noblock() finally: self.__shutdown_request = False self.__is_shut_down.set() … … SocketServer.py中的 BaseServer 和 BaseRequestHandlerPython为网络编程提高了更高级的封装。SocketServer.py 提供了不少网络服务的类。它们的设计很优雅。Python把网络服务抽象成两个主要的类，一个是Server类，用于处理连接相关的网络操作，另外一个则是RequestHandler类，用于处理数据相关的操作。并且提供两个MixIn 类，用于扩展 Server，实现多进程或多线程。在构建网络服务的时候，Server 和 RequestHandler 并不是分开的，RequestHandler的实例对象在Server 内配合 Server工作。主要几个Server关系如下： 12345678910111213+------------+| BaseServer |+------------+ | v+-----------+ +------------------+| TCPServer |-------&gt;| UnixStreamServer |+-----------+ +------------------+ | v+-----------+ +--------------------+| UDPServer |-------&gt;| UnixDatagramServer |+-----------+ +--------------------+ BaseServer 分析BaseServer 通过init初始化，对外提供serve_forever和 handler_request方法，在这里初始化动作是在django.core.servers.basehttp.py run()函数中httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)触发，其中httpd_cls是通过type()函数动态加载的WSGIServer类，这里httpd_cls表示:&lt;class &#39;django.core.servers.basehttp.WSGIServer&#39;&gt;,继承自：&lt;class &#39;django.core.servers.basehttp.WSGIServer&#39;&gt;,socketserver.ThreadingMixIn。 init 初始化:12345678def __init__(self, server_address, RequestHandlerClass): # 初始化,传入构建一个Socket服务器所必需的address以及每个请求到达时的处理类 &quot;&quot;&quot;Constructor. May be extended, do not override.&quot;&quot;&quot; self.server_address = server_address # RequestHandlerClass 注册 handle 函数，在finish_request 中实例化，调用用户定义的 handle 函数 self.RequestHandlerClass = RequestHandlerClass self.__is_shut_down = threading.Event() self.__shutdown_request = False __init__源码很简单。主要作用是创建server对象，并初始化server地址和处理请求的class。熟悉socket编程应该很清楚，server_address是一个包含主机和端口的元组。 serve_forever创建了server对象之后，使用server对象开启一个无限循环。1234567891011121314151617181920212223def serve_forever(self, poll_interval=0.5): &quot;&quot;&quot;Handle one request at a time until shutdown. Polls for shutdown every poll_interval seconds. Ignores self.timeout. If you need to do periodic tasks, do them in another thread. &quot;&quot;&quot; self.__is_shut_down.clear() try: while not self.__shutdown_request: # XXX: Consider using another file descriptor or # connecting to the socket to wake this up instead of # polling. Polling reduces our responsiveness to a # shutdown request and wastes cpu at all other times. # 调用 select 监视请求，处理 EINTR 异常 r, w, e = _eintr_retry(select.select, [self], [], [], poll_interval) if self in r: # 有请求进来 self._handle_request_noblock() finally: self.__shutdown_request = False self.__is_shut_down.set() serve_forever接受一个参数poll_interval，用于表示select轮询的时间。然后进入一个无限循环，调用select方式进行网络IO的监听。如果select函数返回，表示有IO连接或数据，那么将会调用_handle_request_noblock方法。 _handle_request_noblock1234567891011121314151617181920212223def _handle_request_noblock(self): &quot;&quot;&quot;Handle one request, without blocking. I assume that select.select has returned that the socket is readable before this function was called, so there should be no risk of blocking in get_request(). 处理一个请求，不会阻塞。 我假设select.select返回了在调用此函数之前套接字是可读的，因此get_request（）中不应存在阻塞的风险。 &quot;&quot;&quot; try: # 接收请求 accept,get_request 由子类实现，一般为接收请求，返回 socket request, client_address = self.get_request() except socket.error: return if self.verify_request(request, client_address): try: # BaseServer.process_request 中有 BaseRequestHandler 的回调动作,实例化用户定义的 handler, __init__ 中完成对 handle() 的调用 self.process_request(request, client_address) except: self.handle_error(request, client_address) # 关闭连接 self.shutdown_request(request) else: self.shutdown_request(request) _handle_request_noblock方法即开始处理一个请求，并且是非阻塞。该方法通过get_request方法获取连接，具体的实现在其子类。一旦得到了连接，调用verify_request方法验证请求。验证通过，即调用process_request处理请求。如果中途出现错误，则调用handle_error处理错误，以及shutdown_request结束连接。 get_request 在这里，调用的是子类class TCPServer(BaseServer)中的get_request。TCPServer 继承了BaseServer，初始化的时候，进行了socket套接字的创建。 get_request：该类最重要的方法就是 get_request。该方法进行返回socket对象的请求连接。1234567def get_request(self): &quot;&quot;&quot;Get the request and client address from the socket. May be overridden. 从套接字获取请求和客户端地址。可以覆盖。 &quot;&quot;&quot; return self.socket.accept() get_request方法是在BaseServer基类中的_handle_request_noblock中调用，从那里里传入套接字对象获取的连接信息。如果是UDPServer，这里获取的就是UDP连接。此外，TCPServer还提供了一个 fileno 方法，提供给基类的select调用返回文件描述符。 verify_request1234567def verify_request(self, request, client_address): &quot;&quot;&quot;Verify the request. May be overridden. Return True if we should proceed with this request. 验证请求。 可以覆盖。如果我们应该继续这个请求，则返回True。 &quot;&quot;&quot; return True 该方法对request进行验证，通常会被子类重写。简单的返回True即可，然后进入process_request方法处理请求。 process_request在这里调用的是在ThreadingMixIn类定义的process_request函数，并不是BaseServer类中的process_request。123456789101112131415161718192021222324252627class ThreadingMixIn: &quot;&quot;&quot;Mix-in class to handle each request in a new thread.用于处理新线程中的每个请求的混合类。&quot;&quot;&quot; # Decides how threads will act upon termination of the # main process # 决定线程在主进程终止时的操作方式 daemon_threads = False def process_request_thread(self, request, client_address): &quot;&quot;&quot;Same as in BaseServer but as a thread. In addition, exception handling is done here. 与BaseServer相同，但这里作为线程。此外，此处完成异常处理。 &quot;&quot;&quot; try: self.finish_request(request, client_address) self.shutdown_request(request) except: self.handle_error(request, client_address) self.shutdown_request(request) def process_request(self, request, client_address): &quot;&quot;&quot;Start a new thread to process the request.启动一个新线程来处理请求&quot;&quot;&quot; t = threading.Thread(target = self.process_request_thread, args = (request, client_address)) t.daemon = self.daemon_threads t.start() process_request方法是mixin的入口，MixIn子类通过重写该方法，进行多线程或多进程的配置。调用finish_request完成请求的处理，同时调用shutdown_request结束请求。 finish_request12345def finish_request(self, request, client_address): &quot;&quot;&quot;Finish one request by instantiating RequestHandlerClass. 通过实例化RequestHandlerClass完成一个请求。 &quot;&quot;&quot; self.RequestHandlerClass(request, client_address, self) finish_request方法将会处理完毕请求。创建RequestHandlerClass对象，并通过RequestHandlerClass做具体的处理。 其中self.RequestHandlerClass(request, client_address, self):在__init__()中定义为self.RequestHandlerClass = RequestHandlerClass。 在这里，RequestHandlerClass参数是上一博文中，在:django.core.servers.basehttp.py run()函数（1）中定义的WSGIRequestHandler类，在（2）中进行初始化，既调用BaseServer中的__init__()。12345678def run(addr, port, wsgi_handler, ipv6=False, threading=False, server_cls=WSGIServer): server_address = (addr, port) if threading: httpd_cls = type(str(&apos;WSGIServer&apos;), (socketserver.ThreadingMixIn, server_cls), &#123;&#125;) # (1)这里,动态加载类，这里httpd_cls:&lt;class &apos;django.core.servers.basehttp.WSGIServer&apos;&gt;,继承自：&lt;class &apos;django.core.servers.basehttp.WSGIServer&apos;&gt;,socketserver.ThreadingMixIn else: httpd_cls = server_cls httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6) #(2)这里,参数WSGIRequestHandler:&lt;class &apos;django.core.servers.basehttp.WSGIRequestHandler&apos;&gt; … … 因此，RequestHandlerClass是由django.core.servers.basehttp.py: def run() -&gt; httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)传递过来的参数WSGIRequestHandler:django.core.servers.basehttp.WSGIRequestHandler。 也就是说当执行self.RequestHandler(request, client_address, self)时等同于执行django.core.servers.basehttp.WSGIRequestHandler(request, client_address, self)。 WSGIRequestHandlerdjango.core.servers.basehttp.WSGIRequestHandler(request, client_address, self)。在这里，初始化WSGIRequestHandler的时候可以看到并没有init()函数，查看继承关系，django.core.servers.basehttp.WSGIRequestHandler -&gt;simple_server.WSGIRequestHandler -&gt;BaseHTTPServer.BaseHTTPRequestHandler -&gt;SocketServer.StreamRequestHandler -&gt;SocketServer.BaseRequestHandler在这里即调用BaseRequestHandler类__init__ 完成对 handle() 的调用。 BaseRequestHandler 分析所有requestHandler都继承BaseRequestHandler基类。12345678910111213141516171819class BaseRequestHandler: def __init__(self, request, client_address, server): self.request = request # 客户端请求对象,&lt;class &apos;socket._socketobject&apos;&gt; self.client_address = client_address # 客户端地址,(&apos;192.168.31.178&apos;, 50029) self.server = server # 服务端 self.setup() # 调用子类的setup()函数，处理socket连接 try: self.handle() finally: self.finish() def setup(self): pass def handle(self): pass def finish(self): pass BaseRequestHandler是请求处理程序类的基类，该类会处理每一个请求。 __init__()为每个要处理的请求实例化该类。 初始化对象的时候，设置请求request对象、client_address和server，然后调用setup方法，子类会重写该方法，用于处理socket连接，接下来的将是handler和finish方法。 要实现特定服务，需要做的就是派生一个定义handle（）方法的类。所有对请求的处理，都可以重写handler方法。可以简单的理解为：setup()是处理前的初始化操作，handle()是处理请求，finish()是清理操作。 setup(self) 设置完请求request对象、client_address和server后，接着执行self.setup()，该函数在子类StreamRequestHandler实现。 StreamRequestHandler。它继承了BaseRequestHandler。基类的setup方法和finish方法被它重写，用于通过连接实现缓存文件的读写操作。 12345678910111213141516171819202122232425262728293031323334class StreamRequestHandler(BaseRequestHandler): &quot;&quot;&quot; rfile、wfile的默认缓冲区大小。我们默认将rfile设为buffered，否则对于大数据(每个字节的getc()调用)会很慢;我们将wfile设为无缓冲，因为(a)通常在写入()之后，我们想要读取并且需要刷新该行;(b)对未缓冲文件的大写入通常由stdio优化。 &quot;&quot;&quot; # 为流式套接字定义rfile和wfile rbufsize = -1 wbufsize = 0 # 应用于请求套接字的超时（如果不是None）。 timeout = None # 如果为True，则禁用此套接字的nagle算法。 # 仅在wbufsize！= 0时使用，以避免小数据包。 disable_nagle_algorithm = False def setup(self): self.connection = self.request if self.timeout is not None: self.connection.settimeout(self.timeout) if self.disable_nagle_algorithm: self.connection.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, True) self.rfile = self.connection.makefile(&apos;rb&apos;, self.rbufsize) # 一个类似文件的对象，可以用来接收客户端的数据 self.wfile = self.connection.makefile(&apos;wb&apos;, self.wbufsize) # 一个类似文件的对象，可以向客户端返回数据 def finish(self): if not self.wfile.closed: try: self.wfile.flush() except socket.error: # 此处可能发生最终套接字错误，例如本地错误ECONNABORTED。 pass self.wfile.close() self.rfile.close() setup setup判断了是否使用nagle算法。然后设置对应的连接属性。最重要的就是创建了一个可读（rfile）和一个可写（wfile）的“文件”对象，他们实际上并不是创建了文件，而是封装了读取数据和发送数据的操作，抽象成为对文件的操作。可以理解为 self.rfile 就是读取客户端数据的对象，它有一些方法可以读取数据。self.wfile则是用来发送数据给客户端的对象。后面的操作，客户端数据到来会被写入缓冲区可读，需要向客户端发送数据的时候，只需要向可写的文件中write数据即可。 finish在finish()中清理了对应的文件对象，同时wfile关闭之前需要刷新，将一些没有向客户端返回数据数据返回掉。123456789def finish(self): if not self.wfile.closed: # wfile关闭之前需要刷新 try: self.wfile.flush() except socket.error: pass self.wfile.close() self.rfile.close() handle()django.core.servers.basehttp.handle() handle()，调用子类django.core.servers.basehttp.WSGIRequestHandler中的handle()函数，主要处理的是HTTP是否保持连接的问题，如果保持连接就持续处理客户请求，否则就结束，最后使用shutdown来关闭socket的功能。handle_one_request()比较重要语句：1234567891011121314151617def handle(self): self.close_connection = True self.handle_one_request() while not self.close_connection: # 连接没有关闭，循环处理每一个请求 self.handle_one_request() try: &quot;&quot;&quot; 使用shutdown来关闭socket的功能 SHUT_RDWR：关闭读写，即不能使用send/write/recv/read等 SHUT_RD：关闭读，即不能使用read/recv等 SHUT_WR:关闭写功能，即不能使用send/write等 除此之外，还将缓冲区中的内容清空 &quot;&quot;&quot; self.connection.shutdown(socket.SHUT_WR) except (socket.error, AttributeError): pass handle_one_request()12345678910111213141516171819202122232425262728293031def handle_one_request(self): &quot;&quot;&quot;Copy of WSGIRequestHandler.handle() but with different ServerHandler WSGIRequestHandler.handle（）的副本，但具有不同的ServerHandler &quot;&quot;&quot; # 读取第一行raw_requestline，一般格式应该是：COMMAND PATH VERSION\r\n；解析请求。这里：&apos;GET /i18n/js/horizon+openstack_dashboard/ HTTP/1.1\r\n&apos; self.raw_requestline = self.rfile.readline(65537) if len(self.raw_requestline) &gt; 65536: # 如果解析的请求地址长度大于65536个字节，发送和记录一个414错误回复给client。 self.requestline = &apos;&apos; self.request_version = &apos;&apos; self.command = &apos;&apos; self.send_error(414) return # 解析请求（内部）。请求应存储在self.raw_requestline中; 结果在self.command，self.path，self.request_version和self.headers中。 # 返回True表示成功，False表示失败; 失败时，会发回错误。 if not self.parse_request(): return # 初始化一个服务器处理程序，初始化动作在父类中实现 # ServerHandler() -&gt; # django.core.servers.basehttp.ServerHandler()-&gt; # wsgiref.simple_server.ServerHandler() -&gt; # wsgiref.handlers.SimpleHandler().__init__() # python重定向sys.stdin、sys.stdout和sys.stderr:标准输入、标准输出和错误输出 # handler:&lt;django.core.servers.basehttp.ServerHandler object at 0x7fca4bdc64d0&gt; handler = ServerHandler( self.rfile, self.wfile, self.get_stderr(), self.get_environ() ) # self:&lt;django.core.servers.basehttp.WSGIRequestHandler object at 0x7fee45763550&gt; handler.request_handler = self # backpointer for logging &amp; connection closing 用于记录和连接关闭的backpointer handler.run(self.server.get_app()) 其中，self.parse_request()，既调用父类中的BaseHTTPServer.BaseHTTPRequestHandler.parse_request()，解析请求（内部）。需要解析的请求存储在self.raw_requestline中; 结果在self.command，self.path，self.request_version和self.headers中。返回True表示成功，False表示失败; 失败时，会发回错误。command：是一个（区分大小写）关键字，如GET或POST。path：是一个包含请求的路径信息的字符串。应该是字符串“HTTP / 1.0”或“HTTP / 1.1”。使用URL编码方案进行编码（使用％xx表示带有十六进制代码xx的ASCII字符。request_version：包括请求的HTTP协议版本号的字符串，样例：’HTTP/1.0’。headers：headers是包含头信息的mimetools.Message（或派生类）的实例; HTTP 请求（request）http 请求分为三个部分： 1. 第一行：请求类型、地址和版本号 2. 头部信息：HTTP header 3. 数据部分 标准的 HTTP 请求是：123456789GET / HTTP/1.1Host: cizixs.comUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:42.0) Gecko/20100101 Firefox/42.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateConnection: keep-aliveIf-Modified-Since: Thu, 25 Feb 2016 16:00:57 GMTCache-Control: max-age=0 标准的 HTTP 响应头部：12345678910HTTP/1.1 304 Not ModifiedServer: GitHub.comDate: Thu, 24 Mar 2016 06:21:25 GMTLast-Modified: Thu, 25 Feb 2016 16:00:57 GMTaccess-control-allow-origin: *Expires: Thu, 24 Mar 2016 06:31:25 GMTCache-Control: max-age=600X-GitHub-Request-Id: 3AF60A59:7CE3:1C889201:56F38765 data... parse_request()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768def parse_request(self) self.command = None # set in case of error on the first line # 默认请求版本。这只会影响响应，直到请求行被解析为止，因此它主要决定客户端在发送请求格式错误时返回什么。大多数web服务器默认为HTTP 0.9，即不发送状态行。 self.request_version = version = self.default_request_version # 关闭连接设置为真 self.close_connection = 1 # 原始请求行 requestline = self.raw_requestline # 删除 requestline 字符串末尾的指定字符，这里表示换行 requestline = requestline.rstrip(&apos;\r\n&apos;) self.requestline = requestline # 默认一空格分割请求行 words = requestline.split() if len(words) == 3: command, path, version = words if version[:5] != &apos;HTTP/&apos;: # 如果请求版本不是HTTP/开头，则返回400 self.send_error(400, &quot;Bad request version (%r)&quot; % version) return False try: # 例如version=HTTP/1.1，则返回1.1 base_version_number = version.split(&apos;/&apos;, 1)[1] # 返回[&apos;1&apos;, &apos;1&apos;] version_number = base_version_number.split(&quot;.&quot;) # RFC 2145 3.1节规定只能有一个&apos;.&apos; 和主要和次要数字必须被视为单独的整数; if len(version_number) != 2: # 如果包含版本好的数字少于两个则抛出异常 raise ValueError # 类型转换(1, 1) version_number = int(version_number[0]), int(version_number[1]) except (ValueError, IndexError): self.send_error(400, &quot;Bad request version (%r)&quot; % version) return False # 如果版本好大于等于(1, 1)，以及支持的HTTP协议版本大于等于&quot;HTTP/1.1&quot;，则表示请求的版本号正确，关闭连接设置为假。 if version_number &gt;= (1, 1) and self.protocol_version &gt;= &quot;HTTP/1.1&quot;: self.close_connection = 0 if version_number &gt;= (2, 0): self.send_error(505, &quot;Invalid HTTP Version (%s)&quot; % base_version_number) return False elif len(words) == 2: # 请求第一行2个，即“请求类型”、“地址”和“版本号”中缺少一个，则返回400错误。 command, path = words self.close_connection = 1 if command != &apos;GET&apos;: self.send_error(400, &quot;Bad HTTP/0.9 request type (%r)&quot; % command) return False elif not words: return False else: self.send_error(400, &quot;Bad request syntax (%r)&quot; % requestline) return False # 如果http请求第一行为：GET / HTTP/1.1，则：self.command=GET, self.path=/, self.request_version=HTTP/1.1 self.command, self.path, self.request_version = command, path, version # 检查标题并查找连接指令 self.headers = self.MessageClass(self.rfile, 0) # 请求头中查找“Connection: keep-alive” conntype = self.headers.get(&apos;Connection&apos;, &quot;&quot;) if conntype.lower() == &apos;close&apos;: # 关闭请求连接 self.close_connection = 1 elif (conntype.lower() == &apos;keep-alive&apos; and self.protocol_version &gt;= &quot;HTTP/1.1&quot;): # 保持请求连接 self.close_connection = 0 return True handle_one_request()最后执行到handler.run(self.server.get_app())这里包含两个动作：self.server.get_app()、handler.run() self.server.get_app()，/usr/lib/python2.7/wsgiref/simple_server.py:WSGIServer().get_app()123def get_app(self): # &lt;django.contrib.staticfiles.handlers.StaticFilesHandler object at 0x7fee45834c10&gt; return self.application 返回一个StaticFilesHandler类对象，继承WSGIHandler，它的目的是为了判断每个请求，如果是常规的url请求则直接分配到某个view中去执行，如果是静态文件规则那么将不会找view而是响应这个文件。这里请求的地址为：/i18n/js/horizon+openstack_dashboard/看上去是一个静态文件。 handler.run()，/usr/lib/python2.7/wsgiref/handlers.py(76)：BaseHandler.run() 12345678910111213141516def run(self, application): &quot;&quot;&quot;Invoke the application调用应用程序&quot;&quot;&quot; try: # 为一个请求设置环境，包括输入、错误输出。 self.setup_environ() # 调用：/usr/local/lib/python2.7/dist-packages/django/contrib/staticfiles/handlers.py(62)__call__() self.result = application(self.environ, self.start_response) # 发送任何可迭代数据，然后关闭self和iterable self.finish_response() except: try: self.handle_error() except: # If we get an error handling an error, just give up already! self.close() raise # ...and let the actual server figure it out. self.result = application(self.environ, self.start_response) -&gt;/usr/local/lib/python2.7/dist-packages/django/contrib/staticfiles/handlers.py(62)StaticFilesHandler(WSGIHandler).call() -&gt;/usr/local/lib/python2.7/dist-packages/django/core/handlers/wsgi.py(153)WSGIHandler(base.BaseHandler).call()123456789101112131415161718def __call__(self, environ, start_response): set_script_prefix(get_script_name(environ)) signals.request_started.send(sender=self.__class__, environ=environ)# 向接受通知的注册者发送通知 request = self.request_class(environ)# 调用WSGIRequest实例化请求 response = self.get_response(request) # 调用处理方法处理request,返回给定HttpRequest的HttpResponse对象 response._handler_class = self.__class__# 设置_handler_class 为当前处理的类 status = &apos;%d %s&apos; % (response.status_code, response.reason_phrase)# 相应结果的状态码和对应描述 # 获取响应的响应头部信息，获取响应的cookie信息 response_headers = [ *response.items(), *((&apos;Set-Cookie&apos;, c.output(header=&apos;&apos;)) for c in response.cookies.values()), ] start_response(status, response_headers)# 设置响应的响应头部信息 if getattr(response, &apos;file_to_stream&apos;, None) is not None and environ.get(&apos;wsgi.file_wrapper&apos;):# 判断响应中是否有文件传输 response = environ[&apos;wsgi.file_wrapper&apos;](response.file_to_stream) return response# 返回处理结果 调用处理方法处理request,返回给定HttpRequest的HttpResponse对象。1234567891011121314def get_response(self, request): &quot;&quot;&quot;Return an HttpResponse object for the given HttpRequest.返回给定HttpRequest的HttpResponse对象。&quot;&quot;&quot; # Setup default url resolver for this thread为此线程设置默认URL解析程序 set_urlconf(settings.ROOT_URLCONF)# 设置url配置 # 调用settings.MIDDLEWARE中配置的中间件进行处理， response = self._middleware_chain(request) response._closable_objects.append(request) if response.status_code &gt;= 400: log_response( &apos;%s: %s&apos;, response.reason_phrase, request.path, response=response, request=request, ) return response 至此，简单的分析完成，后续随着自己的理解将进一步补充说明。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Django 源码阅读：服务启动(wsgi)]]></title>
      <url>%2F2019%2F01%2F16%2F2019011601%2F</url>
      <content type="text"><![CDATA[一、写在前面一直没有搞懂openstack horizon wsgi加载机制，这次抽时间看了下django 源码，顺便在horizon组件上进行了调试，同时参考学习了网上一些博客的源码阅读说明用以帮助理解，当然还没有理解透彻，仅当个学习笔记。 邮箱地址：jpzhang.ht@gmail.com个人博客：https://jianpengzhang.github.io/CSDN博客：http://blog.csdn.net/u011521019 ￼# 二、入口文件horizon 开发阶段都是通过: python manage.py runserver 0.0.0.0:8001开始的，该命令启用Django提供的轻量级的开发用的Web服务器。默认情况下，服务器运行在IP地址127.0.0.1的8000端口上。如果要自定义服务器端口和地址，可以显式地传递一个IP地址和端口号给它。例如和上面命令一样。Horizon的manage.py 文件里只有简单的几行代码，基本上和其他django项目一样，这里主要通过horizon项目来学习Django 的启动入口。12345678910111213import osimport sysfrom django.core.management import execute_from_command_lineif __name__ == &quot;__main__&quot;: # 将settings模块设置到环境变量中,os.environ[&apos;DJANGO_SETTINGS_MODULE&apos;]:openstack_dashboard.settings os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;openstack_dashboard.settings&quot;) # sys.argv:[&apos;manage.py&apos;, &apos;runserver&apos;, &apos;0.0.0.0:8001&apos;] # 运行ManagementUtility的简单方法。 # ManagementUtility：封装django-admin和manage.py程序的逻辑。 execute_from_command_line(sys.argv) from django.core.management import execute_from_command_line当这行代码开始执行时，首先会去运行django.core.management.init.py这一整个文件，接着找到execute_from_command_line函数并将其导入到当前程序的命名空间中。 由于整个django.core.management.init.py文件都是class类对象和function函数对象，很多时候很自然的就认为这个文件并没有执行任何命令，只是加载了这些个对象，然后在这些个对象中寻找是否包含有execute_from_command_line。最终忽视了其他很重要的代码块from和import。1234567891011import functoolsimport osimport pkgutilimport sysfrom collections import OrderedDict, defaultdictfrom difflib import get_close_matchesfrom importlib import import_moduleimport djangofrom django.apps import apps… … import django 这行代码运行了django.init.py文件。from django.apps import apps这行代码运行了django.apps.init.py文件，然而整个django的开端就是从这里开始的，它落实了非常多的事情（例如：初始化日志模块、加载INSTALL_APP、检查各APP是否正常、检查缓存模块是否正常等），当一切无误时才会往下走，否则将会报错退出程序。 manage.py:12os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;openstack_dashboard.settings&quot;) 这句话绑定了DJANGO_SETTINGS_MODULE的键值，然后将其加载。设置完DJANGO_SETTINGS_MODULE环境变量之后，命令行参数的列表传到了 django/core/management/init.py 中的execute_from_command_line函数。execute_from_command_line这个方法是一个工厂函数，它负责指挥ManagementUtility类利用execute方法来解析参数和启动wsgi服务。 django/core/management/init.py:execute_from_command_line方法：123456789def execute_from_command_line(argv=None): &quot;&quot;&quot;Run a ManagementUtility.&quot;&quot;&quot; &quot;&quot;&quot; 实例化对象ManagementUtility对象后调用execute() &quot;&quot;&quot; utility = ManagementUtility(argv) # execute方法来解析参数和启动wsgi服务 utility.execute() django/core/management/init.py:ManagementUtility：命令管理工具 12345678910111213class ManagementUtility: &quot;&quot;&quot; Encapsulate the logic of the django-admin and manage.py utilities. 封装django-admin和manage.py程序的逻辑。 &quot;&quot;&quot; def __init__(self, argv=None): self.argv = argv or sys.argv[:] # 就是命令行参数 self.prog_name = os.path.basename(self.argv[0]) # 调用这个类的组件名，区分是django-admin还是manage.py; if self.prog_name == &apos;__main__.py&apos;: self.prog_name = &apos;python -m django&apos; self.settings_exception = None # 记录异常 … … 在这里prog_name 就是 manage.py。 实例化ManagementUtility后调用了 execute() 方法，这个函数主要处理子命令的执行，这里的子命令是相对于django-admin.py和manage.py的，举个例子：python manage.py runserver这里的runserver就是子命令。 在这个方法中，会对命令参数进行处理。当解析的的命令是 runserver 时，会有两条路，第一个是执行自动重装的路线（监听文件的修改变化，并实现自动重载），通过 autoreload.check_errors(django.setup)() 完成。另一个路线是参数中有 –noreload 时，就用 django.setup() 来启动服务。如果不是 runserver 而是其他命令，那么会对命令参数 self.argv[1] 进行判断，包括错误处理，是否是 help ，是否是 version ，根据不同的情况显示不同的信息。 execute(self)函数中最重要的是最后一句，即前面的情况都不是，就进入 self.fetch_command(subcommand).run_from_argv(self.argv) ，这边分两步，一步是获取执行命令所需要的类，其次是将命令参数作为参数传递给执行函数执行(代码分析如下)：django/core/management/init.py:execute(self):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081def execute(self): &quot;&quot;&quot; Given the command-line arguments, figure out which subcommand is being run, create a parser appropriate to that command, and run it. 给定命令行参数，找出正在运行的子命令，创建适合该命令的解析器，然后运行它。 &quot;&quot;&quot; try: # 获取命令行输入第一个参数,如果没有则为help subcommand，这里表示 runserver subcommand = self.argv[1] except IndexError: subcommand = &apos;help&apos; # Display help if no arguments were given.如果没有给出参数，则显示帮助。 # Preprocess options to extract --settings and --pythonpath. # These options could affect the commands that are available, so they # must be processed early. parser = CommandParser(usage=&apos;%(prog)s subcommand [options] [args]&apos;, add_help=False, allow_abbrev=False) # 添加命令说明 parser.add_argument(&apos;--settings&apos;) parser.add_argument(&apos;--pythonpath&apos;) parser.add_argument(&apos;args&apos;, nargs=&apos;*&apos;) # catch-all try: &quot;&quot;&quot; options:Namespace(args=[&apos;0.0.0.0:9000&apos;], pythonpath=None, settings=None) args [] &quot;&quot;&quot; options, args = parser.parse_known_args(self.argv[2:]) # 解析后面的参数，options:Namespace(args=[],pythonpath=None,settings=None) handle_default_options(options) # 如果options中的pythonpath或者settings有，则使用传入的路径与文件 except CommandError: pass # Ignore any option errors at this point.此时忽略任何选项错误。 try: settings.INSTALLED_APPS # 当是django-admin命令输入时没有配置文件此时会报错，如果是已经生产的项目则可以导入配置文件中已经配置的应用 except ImproperlyConfigured as exc: self.settings_exception = exc except ImportError as exc: self.settings_exception = exc if settings.configured: # Start the auto-reloading dev server even if the code is broken. # The hardcoded condition is a code smell but we can&apos;t rely on a # flag on the command class because we haven&apos;t located it yet. if subcommand == &apos;runserver&apos; and &apos;--noreload&apos; not in self.argv:# 如果不是runserver并且没有关闭自动重载功能，则执行以下函数 try: autoreload.check_errors(django.setup)() # 调用自动检测文件是否修改如果修改则自动重新启动Django服务 except Exception: # The exception will be raised later in the child process # started by the autoreloader. Pretend it didn&apos;t happen by # loading an empty list of applications. apps.all_models = defaultdict(OrderedDict) apps.app_configs = OrderedDict() apps.apps_ready = apps.models_ready = apps.ready = True # Remove options not compatible with the built-in runserver # (e.g. options for the contrib.staticfiles&apos; runserver). # Changes here require manually testing as described in # #27522. _parser = self.fetch_command(&apos;runserver&apos;).create_parser(&apos;django&apos;, &apos;runserver&apos;) _options, _args = _parser.parse_known_args(self.argv[2:]) for _arg in _args: self.argv.remove(_arg) # In all other cases, django.setup() is required to succeed. else: django.setup() # 初始化django环境 self.autocomplete()# 检测是否是自动完成 if subcommand == &apos;help&apos;:# 如果解析命令为help if &apos;--commands&apos; in args: sys.stdout.write(self.main_help_text(commands_only=True) + &apos;\n&apos;)# 打印出help命令 elif not options.args:# 如果输入参数为空 sys.stdout.write(self.main_help_text() + &apos;\n&apos;) else: self.fetch_command(options.args[0]).print_help(self.prog_name, options.args[0])# 针对某个命令打印相应命令的帮助信息 # Special-cases: We want &apos;django-admin --version&apos; and # &apos;django-admin --help&apos; to work, for backwards compatibility. elif subcommand == &apos;version&apos; or self.argv[1:] == [&apos;--version&apos;]:# 如果输入的命令是打印版本信息 sys.stdout.write(django.get_version() + &apos;\n&apos;)# 则输出当前Django的版本 elif self.argv[1:] in ([&apos;--help&apos;], [&apos;-h&apos;]):# 如果输入参数中包括了--help -h 则打印帮助信息 sys.stdout.write(self.main_help_text() + &apos;\n&apos;) else: self.fetch_command(subcommand).run_from_argv(self.argv)# 如果命令行输入单个命令，则寻找该命令，然后执行输入的参数 前面几行不难看懂是进行参数获取的，后面到了解析这块又用到CommandParser这个类。 12345678910111213141516# Preprocess options to extract --settings and --pythonpath.# These options could affect the commands that are available, so they# must be processed early.parser = CommandParser(usage=&apos;%(prog)s subcommand [options] [args]&apos;, add_help=False, allow_abbrev=False) # 添加命令说明parser.add_argument(&apos;--settings&apos;)parser.add_argument(&apos;--pythonpath&apos;)parser.add_argument(&apos;args&apos;, nargs=&apos;*&apos;) # catch-alltry: &quot;&quot;&quot; options:Namespace(args=[&apos;0.0.0.0:9000&apos;], pythonpath=None, settings=None) args [] &quot;&quot;&quot; options, args = parser.parse_known_args(self.argv[2:]) # 解析后面的参数，options:Namespace(args=[],pythonpath=None,settings=None) handle_default_options(options) # 如果options中的pythonpath或者settings有，则使用传入的路径与文件except CommandError: pass # Ignore any option errors at this point.此时忽略任何选项错误。 通过进入该类查看实现过程，该类的路径为django/core/management/base.py中，代码如下：12345678910111213141516171819202122232425class CommandParser(ArgumentParser): &quot;&quot;&quot; Customized ArgumentParser class to improve some error messages and prevent SystemExit in several occasions, as SystemExit is unacceptable when a command is called programmatically. 定制ArgumentParser类来改进一些错误消息，并在某些情况下防止SystemExit，因为在以编程方式调用命令时SystemExit是不可接受的。 &quot;&quot;&quot; def __init__(self, *, missing_args_message=None, called_from_command_line=None, **kwargs): self.missing_args_message = missing_args_message self.called_from_command_line = called_from_command_line super().__init__(**kwargs) def parse_args(self, args=None, namespace=None): # Catch missing argument for a better error message # 捕获缺少的参数以获得更好的错误消息 if (self.missing_args_message and not (args or any(not arg.startswith(&apos;-&apos;) for arg in args))): self.error(self.missing_args_message) return super().parse_args(args, namespace) def error(self, message): if self.called_from_command_line: super().error(message) else: raise CommandError(&quot;Error: %s&quot; % message) 可以看出这个类是对ArgumentParser的继承封装，而ArgumentParser是python基础类包中的一个类，这个函数的目的是将ArgumentParser封装成符合django内部调用的接口形式。 argparse模块可以轻松编写用户友好的命令行界面。 程序定义了它需要的参数，argparse将弄清楚如何解析sys.argv中的参数。 当用户给程序提供无效参数时，argparse模块还会自动生成帮助和使用消息并发出错误。 ArgumentParser通过parse_args()方法解析参数。 这将检查命令行，将每个参数转换为适当的类型，然后调用相应的操作。 在大多数情况下，这意味着将从命令行解析的属性构建一个简单的Namespace对象。 不懂的自行参看其手册。ArgumentParser官方手册。 回过头来继续看execute函数。接下来的一段代码围绕着CommandParser进行。完成命令行的常规设置。运行到options, args = parser.parse_known_args(self.argv[2:])才开始进入解析的关键之处。下面给出了python的官方文档中该函数的说明：1Sometimes a script may only parse a few of the command-line arguments, passing the remaining arguments on to another script or program. In these cases, the parse_known_args() method can be useful. It works much like parse_args() except that it does not produce an error when extra arguments are present. Instead, it returns a two item tuple containing the populated namespace and the list of remaining argument strings. 也就是说，这个函数将当前脚本需要命令参数和其他脚本所需的命令行进行分离，它的返回结果是一个tuple，包含一个填充好的命名空间和剩余的参数字符串列表。此处的options和args的结果形如：123options:Namespace(args=[&apos;0.0.0.0:8001&apos;], pythonpath=None, settings=None) args:self = &lt;django.core.management.ManagementUtility object at 0x7eff4f056ad0&gt; 代码接着运行，将前面函数填充好的命名空间（此处为options参数）传入handle_default_options这个方法去执行。handle_default_options同样在django/core/management/base.py文件中，代码如下： 12345678910111213def handle_default_options(options): &quot;&quot;&quot; Include any default options that all commands should accept here so that ManagementUtility can handle them before searching for user commands. 包括所有命令在此处应接受的任何默认选项，以便ManagementUtility在搜索用户命令之前可以处理它们。 &quot;&quot;&quot; # 上述例子运行解析后，options的传递过来的值：Namespace(args=[&apos;0.0.0.0:8001&apos;], pythonpath=None, settings=None) if options.settings: os.environ[&apos;DJANGO_SETTINGS_MODULE&apos;] = options.settings if options.pythonpath: sys.path.insert(0, options.pythonpath) 它只是完成了两个目标，（1）options中包含setting则配置环境变量；（2）options中包含pythonpath则设置python模块的搜索路径。 继续回到：execute函数。12345678910111213141516171819202122232425262728293031323334try: settings.INSTALLED_APPS # 当是django-admin命令输入时没有配置文件此时会报错，如果是已经生产的项目则可以导入配置文件中已经配置的应用except ImproperlyConfigured as exc: self.settings_exception = excexcept ImportError as exc: self.settings_exception = excif settings.configured: # Start the auto-reloading dev server even if the code is broken. # The hardcoded condition is a code smell but we can&apos;t rely on a # flag on the command class because we haven&apos;t located it yet. if subcommand == &apos;runserver&apos; and &apos;--noreload&apos; not in self.argv:# 如果是runserver并且没有关闭自动重载功能，则执行以下函数 try: autoreload.check_errors(django.setup)() # 调用自动检测文件是否修改如果修改则自动重新启动Django服务 except Exception: # The exception will be raised later in the child process # started by the autoreloader. Pretend it didn&apos;t happen by # loading an empty list of applications. apps.all_models = defaultdict(OrderedDict) apps.app_configs = OrderedDict() apps.apps_ready = apps.models_ready = apps.ready = True # Remove options not compatible with the built-in runserver # (e.g. options for the contrib.staticfiles&apos; runserver). # Changes here require manually testing as described in # #27522. _parser = self.fetch_command(&apos;runserver&apos;).create_parser(&apos;django&apos;, &apos;runserver&apos;) _options, _args = _parser.parse_known_args(self.argv[2:]) for _arg in _args: self.argv.remove(_arg) # In all other cases, django.setup() is required to succeed. else: django.setup() # 初始化django环境 settings.INSTALLED_APPS(django 的配置采用了懒加载机制，后续通过另外的博文进行说明)，这里即执行了django/conf/init__.py:class LazySettings(LazyObject)的getattr()函数，从全局settings更新此索引，使用 importlib.import_module 来加载’openstack_dashboard.settings’配置模块，完成全局Settings实例的初始化。实例化后，配置懒加载也就完成了，程序就回到 execute 函数， INSTALLED_APPS，它表示项目中哪些 app 处于激活状态。元组中的字符串，除了django默认自带的命令之外，就是我们自己定义的app，也就是用python manage.py所启动的app了。 回到 execute 函数，接下去的处理分为两条路，会对命令参数进行处理。当解析的subcommand是 runserver 时，会有两条路，第一个是会自动重装（后续的博文进行说明）的路线，通过 autoreload.check_errors(django.setup)() 代理完成。另一个路线是参数中有 –noreload 时，就用 django.setup() 来启动服务。 这里执行：autoreload.check_errors(django.setup)()其实也是调用django.setup方法；check_errors()，一个装饰器函数，用来检查捕捉一些错误，而django.setup方法:路径：django/init.py:setup()12345678910111213141516171819def setup(set_prefix=True): &quot;&quot;&quot; Configure the settings (this happens as a side effect of accessing the first setting), configure logging and populate the app registry. Set the thread-local urlresolvers script prefix if `set_prefix` is True. 负责初始化日志模块以及所有应用 配置设置，配置日志记录并填充应用程序注册表。 如果`set_prefix`为True，则设置thread-local urlresolvers脚本前缀。 &quot;&quot;&quot; from django.apps import apps from django.conf import settings from django.urls import set_script_prefix from django.utils.log import configure_logging configure_logging(settings.LOGGING_CONFIG, settings.LOGGING) if set_prefix: set_script_prefix( &apos;/&apos; if settings.FORCE_SCRIPT_NAME is None else settings.FORCE_SCRIPT_NAME ) apps.populate(settings.INSTALLED_APPS) 这里主要是这个，apps.populate(settings.INSTALLED_APPS)，加载应用程序配置和模型。 做了几件事情： app_config = AppConfig.create(entry)生成了一个AppConfig实例self.app_configs[app_config.label] = app_config将所有的app实例放到一个order_dict中维护。 app_config.import_models(all_models) 导入models.py 这里不展开，具体可以看django/apps/registry.py 这些准备工作完成后，这里调用了类中自有的一个方法autocomlete，这个函数主要的功能是通过BASH去输出执行建议。 如果不是 runserver 而是其他命令，那么会对命令参数 self.argv[1] 进行判断，包括错误处理，是否是 help ，是否是 version ，根据不同的情况展示不同的信息。 123456789101112131415if subcommand == &apos;help&apos;:# 如果解析命令为help if &apos;--commands&apos; in args: sys.stdout.write(self.main_help_text(commands_only=True) + &apos;\n&apos;)# 打印出help命令 elif not options.args:# 如果输入参数为空 sys.stdout.write(self.main_help_text() + &apos;\n&apos;) else: self.fetch_command(options.args[0]).print_help(self.prog_name, options.args[0])# 针对某个命令打印相应命令的帮助信息# Special-cases: We want &apos;django-admin --version&apos; and# &apos;django-admin --help&apos; to work, for backwards compatibility.elif subcommand == &apos;version&apos; or self.argv[1:] == [&apos;--version&apos;]:# 如果输入的命令是打印版本信息 sys.stdout.write(django.get_version() + &apos;\n&apos;)# 则输出当前Django的版本elif self.argv[1:] in ([&apos;--help&apos;], [&apos;-h&apos;]):# 如果输入参数中包括了--help -h 则打印帮助信息 sys.stdout.write(self.main_help_text() + &apos;\n&apos;)else: self.fetch_command(subcommand).run_from_argv(self.argv)# 如果命令行输入单个命令，则寻找该命令，然后执行输入的参数 最重要的是最后一句，即前面的情况都不是，就进入 self.fetch_command(subcommand).run_from_argv(self.argv) ，这边分两步，一步是会根据subcommand（这是我们执行python manage.py rumserver时传入的第二个参数：runserver），去django.core.management.commands中查找对应的command类，其次是将命令参数作为参数传递给执行函数执行(run_from_argv(self.argv))。 self.fetch_command:是利用django内置的命令管理工具去匹配到具体的模块，例如self.fetch_command(subcommand)其实就相当于是self.fetch_command(‘runserver’)，它最终找到了django.contrib.staticfiles.management.commands.runserver.Command这个命令工具。 django中的命令工具代码组织采用的是策略模式+接口模式，也就是说django.core.management.commands这个目录下面存在各种命令工具，每个工具下面都有一个Command接口，当匹配到’runserver’时调用’runserver’命令工具的Command接口，当匹配到’migrate’时调用’migrate’命令工具的Command接口。 run_from_argv(self.argv):run_from_argv的作用是初始化中间件、启动服务，也就是拉起wgsi(但实际上并不是由它来直接完成，而是由后续很多其他代码来完成)。 django/core/management/init.py:fetch_command(self, subcommand):12345678910111213141516171819202122232425262728293031323334353637def fetch_command(self, subcommand): &quot;&quot;&quot; Try to fetch the given subcommand, printing a message with the appropriate command called from the command line (usually &quot;django-admin&quot; or &quot;manage.py&quot;) if it can&apos;t be found. 要获取给定的子命令，如果找不到，则使用从命令行调用的相应命令（通常为“django-admin”或“manage.py”）打印消息。 &quot;&quot;&quot; # Get commands outside of try block to prevent swallowing exceptions # get_commands() 返回是一个命令与模块映射作用的字典，字典的key是命令名称，value是这个命令实现所在的文件路径。 commands = get_commands()# 获取所有支持的命令 try: # 这里runserver指令对应的返回的app_name应该为&apos;django.contrib.staticfiles&apos; -&gt; &apos;runserver&apos;: &apos;django.contrib.staticfiles&apos;, app_name = commands[subcommand]# 获取命令名称所在的路径或者实例 except KeyError: if os.environ.get(&apos;DJANGO_SETTINGS_MODULE&apos;): # If `subcommand` is missing due to misconfigured settings, the # following line will retrigger an ImproperlyConfigured exception # (get_commands() swallows the original one) so the user is # informed about it. # 如果“subcommand”由于错误配置的设置而丢失，那么下面一行将重新触发一个错误配置的异常(get_commands()吞并原始异常)，以便通知用户。 settings.INSTALLED_APPS else: sys.stderr.write(&quot;No Django settings specified.\n&quot;) possible_matches = get_close_matches(subcommand, commands) sys.stderr.write(&apos;Unknown command: %r&apos; % subcommand) if possible_matches: sys.stderr.write(&apos;. Did you mean %s?&apos; % possible_matches[0]) sys.stderr.write(&quot;\nType &apos;%s help&apos; for usage.\n&quot; % self.prog_name) sys.exit(1) if isinstance(app_name, BaseCommand):# 判断app_name是否是基本命令的实例，还是命令的路径 # If the command is already loaded, use it directly. # 如果已加载该命令，请直接使用它。 klass = app_name else: # 动态加载模块,模块是通过 load_command_class 来动态加载的 klass = load_command_class(app_name, subcommand)# 如果是路径则导入该命令 return klass # 将命令的实例化对象返回 get_commands() 是返回是一个命令与模块映射作用的字典,字典的key是命令名称，value是这个命令实现所在的文件路径（get_commands通过pkgutil第三方类库来做的）:123456789101112131415161718192021222324252627282930313233343536373839&#123;&apos;check&apos;: &apos;django.core&apos;, &apos;compilemessages&apos;: &apos;django.core&apos;, &apos;createcachetable&apos;: &apos;django.core&apos;, &apos;dbshell&apos;: &apos;django.core&apos;, &apos;diffsettings&apos;: &apos;django.core&apos;, &apos;dumpdata&apos;: &apos;django.core&apos;, &apos;flush&apos;: &apos;django.core&apos;, &apos;inspectdb&apos;: &apos;django.core&apos;, &apos;loaddata&apos;: &apos;django.core&apos;, &apos;makemessages&apos;: &apos;django.core&apos;, &apos;makemigrations&apos;: &apos;django.core&apos;, &apos;migrate&apos;: &apos;django.core&apos;, &apos;runserver&apos;: &apos;django.contrib.staticfiles&apos;, &apos;sendtestemail&apos;: &apos;django.core&apos;, &apos;shell&apos;: &apos;django.core&apos;, &apos;showmigrations&apos;: &apos;django.core&apos;, &apos;sqlflush&apos;: &apos;django.core&apos;, &apos;sqlmigrate&apos;: &apos;django.core&apos;, &apos;sqlsequencereset&apos;: &apos;django.core&apos;, &apos;squashmigrations&apos;: &apos;django.core&apos;, &apos;startapp&apos;: &apos;django.core&apos;, &apos;startproject&apos;: &apos;django.core&apos;, &apos;test&apos;: &apos;django.core&apos;, &apos;testserver&apos;: &apos;django.core&apos;, &apos;pull_catalog&apos;: &apos;horizon&apos;, &apos;startdash&apos;: &apos;horizon&apos;, &apos;startpanel&apos;: &apos;horizon&apos;, &apos;compress&apos;: &apos;compressor&apos;, &apos;mtime_cache&apos;: &apos;compressor&apos;, &apos;collectstatic&apos;: &apos;django.contrib.staticfiles&apos;, &apos;findstatic&apos;: &apos;django.contrib.staticfiles&apos;, &apos;clearsessions&apos;: &apos;django.contrib.sessions&apos;, &apos;changepassword&apos;: &apos;django.contrib.auth&apos;, &apos;createsuperuser&apos;: &apos;django.contrib.auth&apos;, &apos;remove_stale_contenttypes&apos;: &apos;django.contrib.contenttypes&apos;, &apos;extract_messages&apos;: &apos;openstack_dashboard&apos;, &apos;make_web_conf&apos;: &apos;openstack_dashboard&apos;, &apos;migrate_settings&apos;: &apos;openstack_dashboard&apos;, &apos;update_catalog&apos;: &apos;openstack_dashboard&apos;&#125; 接着根据“runserver”，返回命令路径：django.contrib.staticfiles，然后通过isinstance() 函数来判断django.contrib.staticfiles是否是BaseCommand类型，因为这里是app_name命令的路径，并不是一个对象，如果是对象就是属于BaseCommand。本质上这里主要用来判断django.contrib.staticfiles是否已经加载，如果加载直接返回该模块，如果不是就通过load_command_class函数动态加载模块。load_command_class的目录在django/core/management/init.py中，代码如下： 1234567891011def load_command_class(app_name, name): &quot;&quot;&quot; Given a command name and an application name, return the Command class instance. Allow all errors raised by the import process (ImportError, AttributeError) to propagate. 给定命令名称和应用程序名称，返回Command类实例。 允许导入过程引发的所有错误（ImportError，AttributeError）传播。 &quot;&quot;&quot; # 如执行 runserver 命令的模块就是 django.contrib.staticfiles.management.commands.runserver # 返回该模块中定义的 Command 类的实例。获得实例后调用了 run_from_argv(self.argv) : module = import_module(&apos;%s.management.commands.%s&apos; % (app_name, name)) # 导入命令所在的包 return module.Command() 这个方法调用python中importlib库中的import_module方法将模块动态载入，然后返回载入模块的Command()。参看management/commands下的每个文件，发现都拥有一个Command类对应相应的命令。综上所诉，之前这个fetch_command返回了一个命令对象。接着研究run_from_argv函数，这个函数同样位于django/core/management/base.py中，它是之前返回的BaseCommand对象中的一个方法，子类django.contrib.staticfiles.management.commands.runserver没有实现该函数，则调用父类BaseCommand中的。 runserver继承对象分布 依次按顺序如下： • django.contrib.staticfiles.management.commands.runserver.Command • django.core.management.commands.runserver.Command • django.core.management.base.BaseCommand • object source/django/core/management/base.py:run_from_argv如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def run_from_argv(self, argv): &quot;&quot;&quot; Set up any environment changes requested (e.g., Python path and Django settings), then run this command. If the command raises a ``CommandError``, intercept it and print it sensibly to stderr. If the ``--traceback`` option is present or the raised ``Exception`` is not ``CommandError``, raise it. 设置所请求的任何环境更改（例如，Python路径和Django设置），然后运行此命令。 如果该命令引发一个``CommandError``， 则拦截它并将其合理地打印到stderr。 如果存在``--traceback``选项或者引发的``Exception``不是``CommandError``，则将其抬起。 &quot;&quot;&quot; self._called_from_command_line = True # create_parser接受两个参数，第一个是prog_name，即谁执行这个指令，此处是&apos;manage.py&apos; # 第二个是subcommand，即运行的是什么指令，此处是&apos;runserver&apos; parser = self.create_parser(argv[0], argv[1]) # options:Namespace(addrport=&apos;0.0.0.0:8001&apos;, insecure_serving=False, no_color=False, pythonpath=None, settings=None, traceback=False, use_ipv6=False, use_reloader=True, use_static_handler=True, use_threading=True, verbosity=1) # 返回一个Namespace的实例 options = parser.parse_args(argv[2:]) # 对象转成字典,这里执行完cmd_options的值为：&#123;&apos;use_static_handler&apos;: True, &apos;settings&apos;: None, &apos;pythonpath&apos;: None, &apos;verbosity&apos;: 1, &apos;traceback&apos;: False, &apos;addrport&apos;: &apos;0.0.0.0:8001&apos;, &apos;no_color&apos;: False, &apos;use_ipv6&apos;: False, &apos;use_threading&apos;: True, &apos;use_reloader&apos;: True, &apos;insecure_serving&apos;: False&#125; cmd_options = vars(options) # Move positional args out of options to mimic legacy optparse args = cmd_options.pop(&apos;args&apos;, ()) # 设置默认参数 handle_default_options(options) try: # 异常捕获包裹的execute # 在 execute 中会做一些设置参数的错误检查，然后设置句柄: self.execute(*args, **cmd_options) except Exception as e: if options.traceback or not isinstance(e, CommandError): raise # SystemCheckError takes care of its own formatting. if isinstance(e, SystemCheckError): self.stderr.write(str(e), lambda x: x) else: self.stderr.write(&apos;%s: %s&apos; % (e.__class__.__name__, e)) sys.exit(1) finally: try: connections.close_all() except ImproperlyConfigured: # Ignore if connections aren&apos;t setup at this point (e.g. no # configured settings). pass 这个函数的作用就是设置好环境变量，然后取运行指令。这个文件的结构有点类似于前面的execute，当前类对象的run_from_argv方法中调用了self.execute(*args, **cmd_options)方法，由于请求的入口是django.contrib.staticfiles.management.commands.runserver.Command对象，因此python并不会去执行BaseCommand.execute而是执行django.core.management.commands.runserver.Command.execute，最后通过super(Command, self).execute(*args, **options)来执行BaseComand.execute。 django.core.management.commands.runserver.Command.execute函数在子类重新定义，这部分的代码如下:12345678def execute(self, *args, **options):# 调用处理方法 if options[&apos;no_color&apos;]: # We rely on the environment because it&apos;s currently the only # way to reach WSGIRequestHandler. This seems an acceptable # compromise considering `runserver` runs indefinitely. # 我们依赖环境，因为这是目前到达WSGIRequestHandler的唯一途径。考虑到“runserver”无限期地运行，这似乎是一个可以接受的折衷方案。 os.environ[&quot;DJANGO_COLORS&quot;] = &quot;nocolor&quot; super().execute(*args, **options)# 调用父类的执行方法 没有做太多的事情，返回调用父类的execute执行方法，代码如下：123456789101112131415161718192021222324252627282930313233343536def execute(self, *args, **options): &quot;&quot;&quot; Try to execute this command, performing system checks if needed (as controlled by the ``requires_system_checks`` attribute, except if force-skipped). 尝试执行此命令，在需要时执行系统检查（由``requires_system_checks``属性控制，除非强制跳过） &quot;&quot;&quot; # 这里传递进来的options的值为：&#123;&apos;use_static_handler&apos;: True, &apos;settings&apos;: None, &apos;pythonpath&apos;: None, &apos;verbosity&apos;: 1, &apos;traceback&apos;: False, &apos;addrport&apos;: &apos;0.0.0.0:8001&apos;, &apos;no_color&apos;: False, &apos;use_ipv6&apos;: False, &apos;use_threading&apos;: True, &apos;use_reloader&apos;: True, &apos;insecure_serving&apos;: False&#125; if options[&apos;force_color&apos;] and options[&apos;no_color&apos;]: # --no-color和--force-color选项不能一起使用 raise CommandError(&quot;The --no-color and --force-color options can&apos;t be used together.&quot;) if options[&apos;force_color&apos;]: self.style = color_style(force_color=True) elif options[&apos;no_color&apos;]: self.style = no_style() self.stderr.style_func = None if options.get(&apos;stdout&apos;): self.stdout = OutputWrapper(options[&apos;stdout&apos;]) if options.get(&apos;stderr&apos;): self.stderr = OutputWrapper(options[&apos;stderr&apos;], self.stderr.style_func) if self.requires_system_checks and not options.get(&apos;skip_checks&apos;): self.check() if self.requires_migrations_checks: self.check_migrations() output = self.handle(*args, **options) if output: if self.output_transaction: connection = connections[options.get(&apos;database&apos;, DEFAULT_DB_ALIAS)] output = &apos;%s\n%s\n%s&apos; % ( self.style.SQL_KEYWORD(connection.ops.start_transaction_sql()), output, self.style.SQL_KEYWORD(connection.ops.end_transaction_sql()), ) self.stdout.write(output) return output execute 中会做一些设置参数的错误检查，然后设置句柄，关键的核心在output = self.handle(*args, **options)这一行，这里又调用了自己的一个自有方法。基本流转过程: BaseComand.execute方法中调用了self.handle(即：django.core.management.commands.runserver.Command.handle) Command.handle方法中调用了self.run(即：django.core.management.commands.runserver.Command.run)。 Command.run方法调用了self.inner_run(即：django.core.management.commands.runserver.Command.inner_run)。 Command.inner_run方法调用了self.get_handler(即：django.contrib.staticfiles.management.commands.runserver.Command.get_handler) Command.inner_run方法调用了run(即：django.core.servers.basehttp.run)。 代码：django/core/management/commands/runserver.py:handle(self, *args, **options)12345678910111213141516171819202122232425262728293031def handle(self, *args, **options):# 调用处理方法 if not settings.DEBUG and not settings.ALLOWED_HOSTS:# 检查是否是debug模式，如果不是则ALLOWED_HOSTS不能为空 raise CommandError(&apos;You must set settings.ALLOWED_HOSTS if DEBUG is False.&apos;) self.use_ipv6 = options[&apos;use_ipv6&apos;] if self.use_ipv6 and not socket.has_ipv6:# 检查输入参数中是否是ipv6格式，检查当前python是否支持ip raise CommandError(&apos;Your Python does not support IPv6.&apos;) self._raw_ipv6 = False if not options[&apos;addrport&apos;]:# 如果输入参数中没有输入端口则使用默认的端口 self.addr = &apos;&apos; # 默认地址 self.port = self.default_port # 默认端口 else: # 如果设置了ip地址和端口号，用正则匹配出来 m = re.match(naiveip_re, options[&apos;addrport&apos;]) # 检查匹配的ip格式 if m is None: raise CommandError(&apos;&quot;%s&quot; is not a valid port number &apos; &apos;or address:port pair.&apos; % options[&apos;addrport&apos;]) # self.addr:&apos;0.0.0.0&apos;; self.port:&apos;9000&apos; self.addr, _ipv4, _ipv6, _fqdn, self.port = m.groups()# 找出匹配的数据 if not self.port.isdigit(): # 检查端口是否为数字 raise CommandError(&quot;%r is not a valid port number.&quot; % self.port) if self.addr: if _ipv6:# 检查解析出的地址是否合法的ipv6地址 self.addr = self.addr[1:-1] self.use_ipv6 = True self._raw_ipv6 = True elif self.use_ipv6 and not _fqdn: raise CommandError(&apos;&quot;%s&quot; is not a valid IPv6 address.&apos; % self.addr) if not self.addr:# 如果没有输入ip地址则使用默认的地址 self.addr = self.default_addr_ipv6 if self.use_ipv6 else self.default_addr self._raw_ipv6 = self.use_ipv6 self.run(**options) # 运行命令 前面的一大段就是运行runserver时候执行的一些参数准备，关键部分是最后一行的self.run(**options)，run 方法主要时调用了 inner_run(*args, **options) 这个方法: django/core/management/commands/runserver.py:run(self, **options)1234567891011def run(self, **options): &quot;&quot;&quot;Run the server, using the autoreloader if needed.如果需要，使用自动重载程序运行服务器 run 方法主要时调用了 inner_run(*args, **options) 这个方法: &quot;&quot;&quot; use_reloader = options[&apos;use_reloader&apos;]# 根据配置是否自动加载，如果没有输入则default=True if use_reloader:# 当开启了自动加载时，则调用自动启动运行 # 如果开启了自动重启功能则，调用django/utils/autoreload.py中的mian函数处理， autoreload.main(self.inner_run, None, options) else: self.inner_run(None, **options)# 如果没有开启文件更新自动重启服务功能则直接运行 在这里自动加载为True，即options[‘use_reloader’]:True。会调用django.utils.autoreload中的python_reloader新开一个线程： 1234567891011121314151617181920212223242526def python_reloader(main_func, args, kwargs): if os.environ.get(&quot;RUN_MAIN&quot;) == &quot;true&quot;:# 获取环境变量是RUN_MAIN是否为&quot;true&quot;，第一次运行时，RUN_MAIN没有设置，此时会运行restart_with_reloader函数 _thread.start_new_thread(main_func, args, kwargs)# 开启子线程运行服务程序 try: reloader_thread() # 调用监控函数 except KeyboardInterrupt: pass else: try: exit_code = restart_with_reloader()# 调用重启函数 if exit_code &lt; 0: os.kill(os.getpid(), -exit_code) else: sys.exit(exit_code) except KeyboardInterrupt: passdef main(main_func, args=None, kwargs=None): if args is None: args = () if kwargs is None: kwargs = &#123;&#125; wrapped_main_func = check_errors(main_func)# 添加对man_func的出错处理方法 python_reloader(wrapped_main_func, args, kwargs)# 新开一个线程 这里的main_func是commands/runserver.py中的inner_run方法：django/core/management/commands/runserver.py:inner_run(self, *args, **options)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def inner_run(self, *args, **options): # If an exception was silenced in ManagementUtility.execute in order # to be raised in the child process, raise it now. autoreload.raise_last_exception() threading = options[&apos;use_threading&apos;]# 是否开启多线程模式，当不传入时则默认为多线程模式运行 # &apos;shutdown_message&apos; is a stealth option. shutdown_message = options.get(&apos;shutdown_message&apos;, &apos;&apos;) quit_command = &apos;CTRL-BREAK&apos; if sys.platform == &apos;win32&apos; else &apos;CONTROL-C&apos;# 打印停止服务信息 # 输出基础信息 self.stdout.write(&quot;Performing system checks…\n\n&quot;)# 标准输出输出数据 self.check(display_num_errors=True)# 检查 # Need to check migrations here, so can&apos;t use the # requires_migrations_check attribute. self.check_migrations()# 检查是否migrations是否与数据库一致 now = datetime.now().strftime(&apos;%B %d, %Y - %X&apos;)# 获取当前时间 # 打印时间等信息 self.stdout.write(now) self.stdout.write(( &quot;Django version %(version)s, using settings %(settings)r\n&quot; &quot;Starting development server at %(protocol)s://%(addr)s:%(port)s/\n&quot; &quot;Quit the server with %(quit_command)s.\n&quot; ) % &#123; &quot;version&quot;: self.get_version(), &quot;settings&quot;: settings.SETTINGS_MODULE, &quot;protocol&quot;: self.protocol, &quot;addr&quot;: &apos;[%s]&apos; % self.addr if self._raw_ipv6 else self.addr, &quot;port&quot;: self.port, &quot;quit_command&quot;: quit_command, &#125;) try: # 获取处理 http 的句柄,这部分除了有熟悉的信息输出外，重要的是这个句柄： handler = self.get_handler(*args, **options)# 获取信息处理的handler,默认返回wsgi run(self.addr, int(self.port), handler,# 调用运行函数 ipv6=self.use_ipv6, threading=threading, server_cls=self.server_cls) except socket.error as e: # Use helpful error messages instead of ugly tracebacks. ERRORS = &#123; errno.EACCES: &quot;You don&apos;t have permission to access that port.&quot;, errno.EADDRINUSE: &quot;That port is already in use.&quot;, errno.EADDRNOTAVAIL: &quot;That IP address can&apos;t be assigned to.&quot;, &#125; try: error_text = ERRORS[e.errno] except KeyError: error_text = e self.stderr.write(&quot;Error: %s&quot; % error_text) # Need to use an OS exit because sys.exit doesn&apos;t work in a thread os._exit(1) except KeyboardInterrupt: if shutdown_message: self.stdout.write(shutdown_message) sys.exit(0) 这部分除了有熟悉的信息输出外，重要的是这个句柄：1234# 获取处理 http 的句柄,这部分除了有熟悉的信息输出外，重要的是这个句柄：handler = self.get_handler(*args, **options)# 获取WSGIHandlerrun(self.addr, int(self.port), handler,# 调用运行函数 ipv6=self.use_ipv6, threading=threading, server_cls=self.server_cls) gethandler 函数最终会返回一个 WSGIHandler 的实例。WSGIHandler 类只实现了 def \_call__(self, environ, start_response) , 使它本身能够成为 WSGI 中的应用程序, 并且实现 call 能让类的行为跟函数一样。 这里要特别强调一下self.get_handler，它非常重要，三个重点: 1. 因为它负责获取WSGIHandler。 2. 由于请求入口是django.contrib.staticfiles.management.commands.runserver.Command，正好它本来就有get_handler这个方法，因此并没有采用django.core.management.commands.runserver.Command.get_handler。 3. self.get_handler并不会返回一个常规的WSGIHandler而是返回一个StaticFilesHandler。 4. StaticFilesHandler类对象继承WSGIHandler，它的目的是为了判断每个请求，如果是常规的url请求则直接分配到某个view中去执行，如果是静态文件规则那么将不会找view而是响应这个文件。 django/contrib/staticfiles/management/commands/runserver.py:get_handler(self, *args, **options) 123456789101112def get_handler(self, *args, **options): &quot;&quot;&quot; Return the static files serving handler wrapping the default handler, if static files should be served. Otherwise return the default handler. 如果应该提供静态文件，则返回默认处理程序的静态文件服务处理程序。 否则返回默认处理程序。 &quot;&quot;&quot; handler = super().get_handler(*args, **options) use_static_handler = options[&apos;use_static_handler&apos;] insecure_serving = options[&apos;insecure_serving&apos;] if use_static_handler and (settings.DEBUG or insecure_serving): return StaticFilesHandler(handler) return handler 这里handler = super().get_handler(*args, **options)调用父类django.core.management.commands.runserver.Command.get_handler函数：123456def get_handler(self, *args, **options): &quot;&quot;&quot;Return the default WSGI handler for the runner.&quot;&quot;&quot; # 返回运行器的默认WSGI处理程序。 # get_handler 函数最终会返回一个 WSGIHandler 的实例。WSGIHandler 类只实现了 def __call__(self, environ, start_response) , # 使它本身能够成为 WSGI 中的应用程序, 并且实现 __call__ 能让类的行为跟函数一样。 return get_internal_wsgi_application() django.core.servers.basehttp.get_internal__wsgi_application()：123456789101112131415161718192021222324252627282930def get_internal_wsgi_application(): &quot;&quot;&quot; Load and return the WSGI application as configured by the user in ``settings.WSGI_APPLICATION``. With the default ``startproject`` layout, this will be the ``application`` object in ``projectname/wsgi.py``. This function, and the ``WSGI_APPLICATION`` setting itself, are only useful for Django&apos;s internal server (runserver); external WSGI servers should just be configured to point to the correct application object directly. If settings.WSGI_APPLICATION is not set (is ``None``), return whatever ``django.core.wsgi.get_wsgi_application`` returns. 按照用户在`settings.WSGI_APPLICATION``中的配置加载并返回WSGI应用程序。 使用默认的``startproject``布局，这将是``projectname / wsgi.py``中的``application``对象。 这个函数和``WSGI_APPLICATION``设置本身只对Django的内部服务器（runserver）有用。 外部WSGI服务器应该配置为直接指向正确的应用程序对象。 如果没有设置settings.WSGI_APPLICATION（是``None``），则返回``django.core.wsgi.get_wsgi_application``返回的内容。 &quot;&quot;&quot; from django.conf import settings# 导入配置文件 app_path = getattr(settings, &apos;WSGI_APPLICATION&apos;)# 获取配置文件中的wsgi运行的路径 if app_path is None: return get_wsgi_application()# 如果配置文件中没有则django/core/wsgi中的WSGIHandler try: return import_string(app_path) # 如果配置文件中配置，则使用配置文件中的包 except ImportError as err: raise ImproperlyConfigured( &quot;WSGI application &apos;%s&apos; could not be loaded; &quot; &quot;Error importing module.&quot; % app_path ) from err 没有设置settings.WSGI_APPLICATION（是None），则返回django.core.wsgi.get_wsgi_application返回的内容。在这里horizon的settings中没有设置WSGI_APPLICATION。 django.core.wsgi.py: get_wsgi_application():12345678910111213def get_wsgi_application(): &quot;&quot;&quot; The public interface to Django&apos;s WSGI support. Return a WSGI callable. Avoids making django.core.handlers.WSGIHandler a public API, in case the internal WSGI implementation changes or moves in the future. Django的WSGI支持的公共接口。返回一个可调用的WSGI。 &quot;&quot;&quot; # setup是加载log和settings.INSTALLED_APPS django.setup(set_prefix=False)# 初始化django环境 # 返回WSGIHhadler类的一个实例 return WSGIHandler() source/django/init.py:setup(set_prefix=True)123456789101112131415161718192021def setup(set_prefix=True): &quot;&quot;&quot; Configure the settings (this happens as a side effect of accessing the first setting), configure logging and populate the app registry. Set the thread-local urlresolvers script prefix if `set_prefix` is True. 负责初始化日志模块以及所有应用 配置设置，配置日志记录并填充应用程序注册表。 如果`set_prefix`为True，则设置thread-local urlresolvers脚本前缀。 &quot;&quot;&quot; from django.apps import apps from django.conf import settings from django.urls import set_script_prefix from django.utils.log import configure_logging configure_logging(settings.LOGGING_CONFIG, settings.LOGGING)# 配置日志记录 if set_prefix: set_script_prefix( # 设置前缀 &apos;/&apos; if settings.FORCE_SCRIPT_NAME is None else settings.FORCE_SCRIPT_NAME ) # 初始化所有应用,但调试的时候发现没有加载注册，标记下，回头继续看app加载。 apps.populate(settings.INSTALLED_APPS) 完成django.setup(set_prefix=False)执行后，紧接着返回return WSGIHandler()12345678910111213141516171819202122232425class WSGIHandler(base.BaseHandler): request_class = WSGIRequest def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.load_middleware()# 加载中间件 def __call__(self, environ, start_response): set_script_prefix(get_script_name(environ)) signals.request_started.send(sender=self.__class__, environ=environ)# 向接受通知的注册者发送通知 request = self.request_class(environ)# 调用WSGIRequest实例化请求 response = self.get_response(request) # 调用处理方法处理request response._handler_class = self.__class__# 设置_handler_class 为当前处理的类 status = &apos;%d %s&apos; % (response.status_code, response.reason_phrase)# 相应结果的状态码和对应描述 # 获取响应的响应头部信息，获取响应的cookie信息 response_headers = [ *response.items(), *((&apos;Set-Cookie&apos;, c.output(header=&apos;&apos;)) for c in response.cookies.values()), ] start_response(status, response_headers)# 设置响应的响应头部信息 if getattr(response, &apos;file_to_stream&apos;, None) is not None and environ.get(&apos;wsgi.file_wrapper&apos;):# 判断响应中是否有文件传输 response = environ[&apos;wsgi.file_wrapper&apos;](response.file_to_stream) return response# 返回处理结果 12345678910111213141516171819202122232425class WSGIHandler(base.BaseHandler): request_class = WSGIRequest def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.load_middleware()# 加载中间件 def __call__(self, environ, start_response): set_script_prefix(get_script_name(environ)) signals.request_started.send(sender=self.__class__, environ=environ)# 向接受通知的注册者发送通知 request = self.request_class(environ)# 调用WSGIRequest实例化请求 response = self.get_response(request) # 调用处理方法处理request response._handler_class = self.__class__# 设置_handler_class 为当前处理的类 status = &apos;%d %s&apos; % (response.status_code, response.reason_phrase)# 相应结果的状态码和对应描述 # 获取响应的响应头部信息，获取响应的cookie信息 response_headers = [ *response.items(), *((&apos;Set-Cookie&apos;, c.output(header=&apos;&apos;)) for c in response.cookies.values()), ] start_response(status, response_headers)# 设置响应的响应头部信息 if getattr(response, &apos;file_to_stream&apos;, None) is not None and environ.get(&apos;wsgi.file_wrapper&apos;):# 判断响应中是否有文件传输 response = environ[&apos;wsgi.file_wrapper&apos;](response.file_to_stream) return response# 返回处理结果 通过__init__()初始化一个WSGIHandler对象，同时通过self.load_middleware()加载中间件。其中self.load_middleware在当前调用的是父类的实现。完成上述调用后返回到：1234567891011121314def get_handler(self, *args, **options): &quot;&quot;&quot; Return the static files serving handler wrapping the default handler, if static files should be served. Otherwise return the default handler. 如果应该提供静态文件，则返回默认处理程序的静态文件服务处理程序。 否则返回默认处理程序。 &quot;&quot;&quot; handler = super().get_handler(*args, **options) use_static_handler = options[&apos;use_static_handler&apos;]# 使用静态处理程序,这里返回True insecure_serving = options[&apos;insecure_serving&apos;] # 判断当前环境是否是debug模式或者是不安全的模式 if use_static_handler and (settings.DEBUG or insecure_serving): # use_static_handler:True,settings.DEBUG:True最终返回StaticFilesHandler对象 return StaticFilesHandler(handler) return handler 这里跟进去看下StaticFilesHandler(handler)source/django/contrib/staticfiles/handlers.py:class StaticFilesHandler(WSGIHandler)12345678910111213141516class StaticFilesHandler(WSGIHandler): &quot;&quot;&quot; WSGI middleware that intercepts calls to the static files directory, as defined by the STATIC_URL setting, and serves those files. WSGI中间件拦截对STATIC_URL设置所定义的静态文件目录的调用，并为这些文件提供服务。 &quot;&quot;&quot; # May be used to differentiate between handler types (e.g. in a # request_finished signal) handles_files = True def __init__(self, application): self.application = application # 初始化静态目录 # ParseResult(scheme=&apos;&apos;, netloc=&apos;&apos;, path=&apos;/dashboard/static/&apos;, params=&apos;&apos;, query=&apos;&apos;, fragment=&apos;&apos;) self.base_url = urlparse(self.get_base_url()) super().__init__() 到这里完成handler = self.get_handler(*args, **options)，返回一个StaticFilesHandler，StaticFilesHandler类对象继承WSGIHandler，它的目的是为了判断每个请求，如果是常规的url请求则直接分配到某个view中去执行，如果是静态文件规则那么将不会找view而是响应这个文件。接着回到django/core/management/commands/runserver.py(149)inner_run()，执行：run(addr, port, wsgi_handler, ipv6=False, threading=False, server_cls=WSGIServer)django/core/servers/basehttp.py(158)run():1234567891011121314151617181920212223242526272829303132def run(addr, port, wsgi_handler, ipv6=False, threading=False, server_cls=WSGIServer): &quot;&quot;&quot; 这是一个标准的 wsgi 实现。httpd_cls 是 WSGIServer 类，最终的实例化方法在父类 SocketServer 中的 TCPServer 和 BaseServer 中。 包括初始化线程，初始化网络句柄，像下面的 __is_shut_down 和 __shutdown_request 都是在其中初始化的。 addr:&apos;0.0.0.0&apos; port:8001 wsgi_handler:&lt;django.contrib.staticfiles.handlers.StaticFilesHandler object at 0x7ff03a14c5d0&gt; ipv6:False threading:True server_cls:&lt;class &apos;django.core.servers.basehttp.WSGIServer&apos;&gt; &quot;&quot;&quot; server_address = (addr, port)# 服务监听的地址和端口 if threading:# 如果是多线程运行 # 生成一个继承自socketserver.ThreadingMixIn, WSGIServer的类 httpd_cls = type(&apos;WSGIServer&apos;, (socketserver.ThreadingMixIn, server_cls), &#123;&#125;) else: httpd_cls = server_cls httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)# 实例化该类 if threading: # ThreadingMixIn.daemon_threads indicates how threads will behave on an # abrupt shutdown; like quitting the server by the user or restarting # by the auto-reloader. True means the server will not wait for thread # termination before it quits. This will make auto-reloader faster # and will prevent the need to kill the server manually if a thread # isn&apos;t terminating correctly. # ThreadingMixIn.daemon_threads表示线程在突然关闭时的行为方式; # 比如用户退出服务器或通过自动重新加载器重新启动。 # True表示服务器在退出之前不会等待线程终止。 # 这将使自动重新加载器更快，并且如果线程没有正确终止，将防止需要手动终止服务器。 httpd.daemon_threads = True# True表示服务器在退出之前不会等待线程终止。 httpd.set_app(wsgi_handler)# 设置服务类的处理handler httpd.serve_forever() django.core.servers.basehttp.run工厂函数负责只会各个对象负责启动wsgi服务。wsgi_handler参数，这里传递的是StaticFilesHandler。 httpd_cls = type(‘WSGIServer’, (socketserver.ThreadingMixIn, server_cls), {}) 是一种很特殊的写法，通过代码块中WSGIServer类对象可以看出它只继承了wsgiref.simple_server.WSGIServer、object这两个类对象，但是通过type这种写法相当于是强行赋予它一个socketserver.ThreadingMixIn继承对象，它的用意是每次调用这个对象的时候都会单独启用一个线程来处理。另外虽然 WSGIServer 只继承了 wsgiref.simple_server.WSGIServer、object两个对象，但是wsgiref.simple_server.WSGIServer却&lt;递归式&gt;的继承了一堆对象，下面完整的列出WSGIServer继承家族。12345671、django.core.servers.basehttp.WSGIServer;2、wsgiref.simple_server.WSGIServer:实现Python WSGI协议的BaseHTTPServer;3、socketserver.ThreadingMixIn:用于处理新线程中的每个请求的混合类; 4、http.server.HTTPServer5、socketserver.TCPServer6、socketserver.BaseServer7、object httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)这行代码非常重要，因为它是WSGI服务器与django之间相互通信的唯一枢纽通道，也就是说，当WSGI服务对象收到socket请求后，会将这个请求传递给django的WSGIRequestHandler。httpd.set_app(wsgi_handler)是将django.contrib.staticfiles.handlers.StaticFilesHandler 传递给WSGIServer当作一个application，当WSGIServer收到网络请求后，可以将数据分发给django.core.servers.basehttp.WSGIRequestHandler，最终由django.core.servers.basehttp.WSGIRequestHandler将数据传递给application(即：django.contrib.staticfiles.handlers.StaticFilesHandler)。httpd.serve.forever()启动非堵塞网络监听服务。 小结上面所有的过程都是django内部代码的为了启动服务而做的准备，简单的把流程给列出来。 1. 解析运行 python manage.py 所提供的参数，例如: runserver. 2. 根据参数 找到相对应的 命令管理工具。 3. 加载所有的app。 4. 检查端口、ipv4检测、ipv6检测、端口是否占用、线程检查、orm对象检查(表是否创建)。 5. 实例化WSGIRequestHandler，并且将它注册到python Lib库中的WSGIServer中。 6. 最后启动python Lib库中的WSGIServer。 二、处理请求接下来的部分是python Lib库中的WSGIServer运作过程中，如何将接收到的请求分发会django的WSGIRequestHandler。 /usr/lib/python2.7/SocketServer.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class BaseServer: timeout = None def __init__(self, server_address, RequestHandlerClass): &quot;&quot;&quot;Constructor. May be extended, do not override.&quot;&quot;&quot; self.server_address = server_address self.RequestHandlerClass = RequestHandlerClass self.__is_shut_down = threading.Event() self.__shutdown_request = False def serve_forever(self, poll_interval=0.5): &quot;&quot;&quot;Handle one request at a time until shutdown. Polls for shutdown every poll_interval seconds. Ignores self.timeout. If you need to do periodic tasks, do them in another thread. 一次处理一个请求直到关闭，每0.5秒遍历一次文件描述符。忽略 self.timeout。 如果您需要定期执行任务，请执行此操作另一个线程。 &quot;&quot;&quot; # self.__is_shut_down = threading.Event() # Python threading模块提供Event对象用于线程间通信,Python 通过threading.Event()产生一个event对象。event对象维护一个内部标志（标志初始值为False），通过set()将其置为True。wait(timeout)则用于堵塞线程直至Flag被set（或者超时，可选的），isSet()用于查询标志位是否为True，Clear()则用于清除标志位（使之为False）。 self.__is_shut_down.clear() try: while not self.__shutdown_request: # XXX: Consider using another file descriptor or # connecting to the socket to wake this up instead of # polling. Polling reduces our responsiveness to a # shutdown request and wastes cpu at all other times. # 考虑使用另一个文件描述符或连接到套接字来唤醒它而不是轮询。 轮询降低了我们对关闭请求的响应速度，并在其他所有时间浪费cpu。 r, w, e = _eintr_retry(select.select, [self], [], [], poll_interval) if self in r: self._handle_request_noblock() finally: self.__shutdown_request = False self.__is_shut_down.set() def _handle_request_noblock(self): &quot;&quot;&quot;Handle one request, without blocking. I assume that select.select has returned that the socket is readable before this function was called, so there should be no risk of blocking in get_request(). &quot;&quot;&quot; try: request, client_address = self.get_request() except socket.error: return if self.verify_request(request, client_address): try: self.process_request(request, client_address) except: self.handle_error(request, client_address) self.shutdown_request(request) else: self.shutdown_request(request) def verify_request(self, request, client_address): &quot;&quot;&quot;Verify the request. May be overridden. Return True if we should proceed with this request. &quot;&quot;&quot; return True def process_request(self, request, client_address): &quot;&quot;&quot;Call finish_request. Overridden by ForkingMixIn and ThreadingMixIn. 调用finish_request。 由ForkingMixIn和ThreadingMixIn重写。 &quot;&quot;&quot; self.finish_request(request, client_address) self.shutdown_request(request)#关闭请求 def finish_request(self, request, client_address): &quot;&quot;&quot;Finish one request by instantiating RequestHandlerClass. 通过实例化RequestHandlerClass完成一个请求。 &quot;&quot;&quot; self.RequestHandlerClass(request, client_address, self) 上面服务启动的最后一个动作是httpd.serve_forever，调用的是socketserver.BaseServer.serve_forever方法。该方法采用了selector网络模型进行等待数据，每0.5秒遍历一次文件描述符，当有数据进来时，ready变量会是一个socket请求对象，这时会将后续工作转交给self._handler_request_noblock方法(即：socketserver.BaseServer._handler_request_noblock)去处理。socketserver.BaseServer._handler_request_noblock方法基本没做什么事情(self.verify_request压根就没有检查任何东西)，直接就把后续工作转交给 socketserver.BaseServer.process_request 方法。socketserver.BaseServer.process_request也没做什么事情，直接就将后续工作转交给socketserver.BaseServer.finish_request方法，只不过在最后加了一条关闭请求的命令。socketserver.BaseServer.finish_request也没做什么事情，直接就将后续工作转交给socketserver.BaseServer.RequestHandlerClass。socketserver.BaseServer.RequestHandlerClass是由上面httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)传递过来的参数django.core.servers.basehttp.WSGIRequestHandler。 也就是说当执行self.RequestHandler(request, client_address, self)时等同于执行django.core.servers.basehttp.WSGIRequestHandler(request, client_address, self)。 小结serve_forever开启了一个while来无限监听网络层的scoket请求，当一条请求过来时，就层层转交到django.core.servers.basehttp.WSGIRequestHandler手中。 django.core.servers.basehttp.py 单独列出WSGIRequestHandler代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class WSGIRequestHandler(simple_server.WSGIRequestHandler): protocol_version = &apos;HTTP/1.1&apos; def address_string(self): # Short-circuit parent method to not call socket.getfqdn return self.client_address[0] def log_message(self, format, *args): extra = &#123; &apos;request&apos;: self.request, &apos;server_time&apos;: self.log_date_time_string(), &#125; if args[1][0] == &apos;4&apos;: # 0x16 = Handshake, 0x03 = SSL 3.0 or TLS 1.x if args[0].startswith(&apos;\x16\x03&apos;): extra[&apos;status_code&apos;] = 500 logger.error( &quot;You&apos;re accessing the development server over HTTPS, but &quot; &quot;it only supports HTTP.\n&quot;, extra=extra, ) return if args[1].isdigit() and len(args[1]) == 3: status_code = int(args[1]) extra[&apos;status_code&apos;] = status_code if status_code &gt;= 500: level = logger.error elif status_code &gt;= 400: level = logger.warning else: level = logger.info else: level = logger.info level(format, *args, extra=extra) def get_environ(self): # Strip all headers with underscores in the name before constructing # the WSGI environ. This prevents header-spoofing based on ambiguity # between underscores and dashes both normalized to underscores in WSGI # env vars. Nginx and Apache 2.4+ both do this as well. for k in self.headers: if &apos;_&apos; in k: del self.headers[k] return super().get_environ() def handle(self): self.close_connection = True self.handle_one_request() while not self.close_connection: self.handle_one_request() try: self.connection.shutdown(socket.SHUT_WR) except (socket.error, AttributeError): pass def handle_one_request(self): &quot;&quot;&quot;Copy of WSGIRequestHandler.handle() but with different ServerHandler&quot;&quot;&quot; self.raw_requestline = self.rfile.readline(65537) if len(self.raw_requestline) &gt; 65536: self.requestline = &apos;&apos; self.request_version = &apos;&apos; self.command = &apos;&apos; self.send_error(414) return if not self.parse_request(): # An error code has been sent, just exit return handler = ServerHandler( self.rfile, self.wfile, self.get_stderr(), self.get_environ() ) handler.request_handler = self # backpointer for logging &amp; connection closing handler.run(self.server.get_app()) 继续分析，socketserver.BaseServer.RequestHandler(request, client_address, self)等同于django.core.servers.basehttp.WSGIRequestHandler(request, client_address, self)。 首先django.core.servers.basehttp.WSGIRequestHandler的继承分布： django.core.servers.basehttp.WSGIRequestHandler(django/core/servers/basehttp.py) wsgiref.simple_server.WSGIRequestHandler(/usr/lib/python2.7/wsgiref) http.server.BaseHTTPRequestHandler(/usr/local/lib/python2.7/dist-packages/http) socketserver.StreamRequestHandler socketserver.BaseRequestHandler object 从代码上看django.core.servers.basehttp.WSGIRequestHandler并没有init或者call方法，因此需要遍历所有父类对象。 最终在socketserver.BaseRequestHandler中看到了init实例初始化方法，它调用了self.handle方法(即回调了：django.core.servers.basehttp.WSGIRequestHandler.handle)。 12345678910111213141516171819202122232425262728293031323334353637383940class WSGIRequestHandler(simple_server.WSGIRequestHandler): def get_environ(self): # Strip all headers with underscores in the name before constructing # the WSGI environ. This prevents header-spoofing based on ambiguity # between underscores and dashes both normalized to underscores in WSGI # env vars. Nginx and Apache 2.4+ both do this as well. for k in self.headers: if &apos;_&apos; in k: del self.headers[k] return super().get_environ() def handle(self): self.close_connection = True self.handle_one_request() while not self.close_connection: self.handle_one_request() # 这里 try: self.connection.shutdown(socket.SHUT_WR) except (socket.error, AttributeError): pass def handle_one_request(self): &quot;&quot;&quot;Copy of WSGIRequestHandler.handle() but with different ServerHandler&quot;&quot;&quot; self.raw_requestline = self.rfile.readline(65537) if len(self.raw_requestline) &gt; 65536: self.requestline = &apos;&apos; self.request_version = &apos;&apos; self.command = &apos;&apos; self.send_error(414) return if not self.parse_request(): # An error code has been sent, just exit return handler = ServerHandler( self.rfile, self.wfile, self.get_stderr(), self.get_environ() )# 这里实例化了ServerHandler对象。 handler.request_handler = self # backpointer for logging &amp; connection closing handler.run(self.server.get_app())# 意思是将django.contrib.staticfiles.handlers.StaticFilesHandler转交给ServerHandler去运行。 handler = ServerHandler(self.rfile, self.wfile, self.get_stderr(), self.get_environ())实例化了ServerHandler对象。handler.run(self.server.get_app())，意思是将django.contrib.staticfiles.handlers.StaticFilesHandler转交给ServerHandler去运行。 ServerHandler对象并没有run方法，它的继承分布： django.core.servers.basehttp.ServerHandler(django/core/servers/basehttp.py) wsgiref.simple_server.ServerHandler(/usr/lib/python2.7/wsgiref) wsgiref.handlers.SimpleHandler(/usr/lib/python2.7/wsgiref) wsgiref.handlers.BaseHandler object 最终在 wsgiref.handlers.BaseHandler 中找到了run方法。wsgiref.handlers.py: 123456789101112131415161718def run(self, application): &quot;&quot;&quot;Invoke the application&quot;&quot;&quot; # Note to self: don&apos;t move the close()! Asynchronous servers shouldn&apos;t # call close() from finish_response(), so if you close() anywhere but # the double-error branch here, you&apos;ll break asynchronous servers by # prematurely closing. Async servers must return from &apos;run()&apos; without # closing if there might still be output to iterate over. try: self.setup_environ() self.result = application(self.environ, self.start_response) self.finish_response() except: try: self.handle_error() except: # If we get an error handling an error, just give up already! self.close() raise # ...and let the actual server figure it out. application(self.environ, self.start_response)也就相当于是django.contrib.staticfiles.handlers.StaticFilesHandler.call(self.environ, lf.start_response)。 django.contrib.staticfiles.handlers.py:1234def __call__(self, environ, start_response): if not self._should_handle(get_path_info(environ)): return self.application(environ, start_response) return super().__call__(environ, start_response) 通过层层流转，最终进入django的静态文件处理的Handler。 总结environ这个变量在django的WSGIServer和WSGIRequestHandler中扮演这非常重要的角色，因为所有的客户端ip、请求的URL、cookie、session、header等等信息都保存在其中。 WSGIServer： 用于处理socket请求和对接WSGIRequestHandler。 WSGIRequestHandler：针对environ进行预处理和对接WSGIServerHandler。 ServerHandler： 用于执行应用程序(application)和返回响应给WSGIServer。 参考博文：1、https://www.jianshu.com/p/17d78b52c7322、http://www.hongweipeng.com/index.php/archives/1369/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义Horizon]]></title>
      <url>%2F2018%2F11%2F27%2F2018112701%2F</url>
      <content type="text"><![CDATA[自定义Horizon一、写在前面继上篇博文，在这篇博文中说明自定义Horiozn，基于目前OpenStack rocky版本。 邮箱地址：jpzhang.ht@gmail.com个人博客：https://jianpengzhang.github.io/CSDN博客：http://blog.csdn.net/u011521019Horizon 原文阅读地址：https://docs.openstack.org/horizon/ocata/topics/customizing.html ￼## 二、更改Horizon Web标题可以通过将属性SITE_BRANDING添加到local_settings.py（openstack_dashboard/local/local_settings.py），其值将作为覆盖OpenStack Dashboard站点标题（即“OpenStack Dashboard”）。## 三、更改Logo点击链接Web Logo图标也可以用来当超链接，默认点击后的行为是重定向到“horizon：user_home”。可以通过在local_settings.py更新属性SITE_BRANDING_LINK改变超链接的目标，例如:1SITE_BRANDING_LINK = &quot;https://www.baidu.com&quot; 四、自定义页面页脚通过theme的模板添加自定义页脚即可：openstack_dashboard/templates/_footer.html（页面页脚）、openstack_dashboard/templates/_login_footer.html（登录页面页脚）、openstack_dashboard/templates/_login_form_footer.html（登录表单页脚）。默认：_footer.html 1234&#123;% comment %&#125; A simple placeholder template for custom global footer content&#123;% endcomment %&#125; 模板引擎会忽略掉 comment 和 endcomment 之间的所有内容,所以默认情况下，Horizon虽然引入了页脚文件，但是没有加载任何信息。 五、修改Dashboards 和 Panels更改Horizon原生的代码或者其他代码, 可以指定一个自定义Python模块, 该模块将在整个 horizon初始化之后加载, 但在urlconf构造之前加载。例如: 从现有Dashboard注册或取消注册Panel。 更改Dashboard和Panel的名称。 重新排序Dashboard或Panel组中的Panel。 默认Horizon面板基于openstack_dashboard/enabled/文件夹中的文件加载。这些文件是根据文件名顺序加载的，你可以添加更多文件。此文件夹中有一些示例文件（以.example后缀)。 六、Horizon定制模块（覆盖）Horizon具有可用于执行尚未通过配置设置进行自定义的全局覆盖机制。此文件可以执行修补和其他形式的自定义，这是通过启用文件夹的自定义方法无法实现的。要指定包含修改的python模块，请将关键的customization_module添加到local_settings.py中的HORIZON_CONFIG字典中。该值应该是一个字符串，其中包含了用点分隔的python路径符号表示的模块路径。例如:1HORIZON_CONFIG[&quot;customization_module&quot;] = &quot;my_project.overrides&quot; 你可以在自定义模块中执行你喜欢的任何操作。例如，可以更改面板的名称： 1、在openstack_dashboard/locallocal_settings.py添加或者修改customization_module:1HORIZON_CONFIG[&quot;customization_module&quot;] = &quot;myproject.overrides&quot; 2、新建openstack_dashboard/myproject目录，结构看起来如下(当然你可以在其他路径下定义这个python文件)：123.├── __init__.py└── overrides.py 3、overrides.py添加以下代码，即可修改user panel的名称为“User Options”： 123456from django.utils.translation import ugettext_lazy as _import horizon# Rename &quot;User Settings&quot; to &quot;User Options&quot;settings = horizon.get_dashboard(&quot;settings&quot;)user_panel = settings.get_panel(&quot;user&quot;)user_panel.name = _(&quot;User Options&quot;) 注意：以下的修改都在overrides.py文件中。 或者获取instances面板：12projects_dashboard = horizon.get_dashboard(&quot;project&quot;)instances_panel = projects_dashboard.get_panel(&quot;instances&quot;) 或者完全删除它：1projects_dashboard.unregister(instances_panel.__class__) 无法取消注册为default_panel的panel。如果要删除default_panel，则需要在dashboard中将其他panel设置为default_panel，然后取消注册前者。 例如，如果你希望从项目dashboard中删除overview_panel，则可以执行以下操作：1234project = horizon.get_dashboard(&apos;project&apos;)project.default_panel = &quot;instances&quot;overview = project.get_panel(&apos;overview&apos;)project.unregister(overview.__class__) 还可以使用自己的版本覆盖现有方法：123456from openstack_dashboard.dashboards.admin.info import tabsfrom openstack_dashboard.dashboards.project.instances import tablesNO = lambda *x: Falsetables.AssociateIP.allowed = NOtables.SimpleAssociateIP.allowed = NOtables.SimpleDisassociateIP.allowed = NO 还可以通过重新定义其Meta类的columns属性来自定义现有表中显示的列。可以通过3个步骤实现： 1、扩展要修改的表; 2、为此新表重新定义Meta类下的columns属性; 3、修改相关视图的table_class属性，使其指向新表; 例如，如果你希望从NetworksTable中删除Admin State列，则可以执行以下操作：12345678910from openstack_dashboard.dashboards.project.networks import tablesfrom openstack_dashboard.dashboards.project.networks import viewsclass MyNetworksTable(tables.NetworksTable): class Meta(tables.NetworksTable.Meta): columns = (&apos;name&apos;, &apos;subnets&apos;, &apos;shared&apos;, &apos;status&apos;) views.IndexView.table_class = MyNetworksTable 如果要添加列，可以以类似的方式覆盖父表，添加新列定义，然后使用Meta columns属性根据需要控制列顺序。 注意 添加上面的代码后，你会发现这不像上面举例一样正常生效，这是需要由运行Horizon的python进程导入myproject.overrides。如果你的模块不是作为系统范围的python包安装的，那么你可以使它可安装（例如，使用setup.py），或者你可以调整WSGI服务器使用的python路径以包括它的位置。也许最简单的方法是在Apache的配置中向WSGIDaemonProcess行添加一个python路径参数。看上去像：WSGIDaemonProcess [… existing options …] python-path=/home/workspace/horizon/openstack_dashboard/myproject,假设你的目录在/home/workspace/horizon/openstack_dashboard/myproject 我这里为了方便直接修改了/etc/apache2/sites-available/horizon.conf,添加：1WSGIDaemonProcess python-path=/home/workspace/horizon/openstack_dashboard/myproject 重启apache，刷新浏览器即可发现NetworksTable的列已经更新了。 自定义项目和用户表列Keystone V3可以存储有关项目和用户的额外信息。使用Horizon定制模块（覆盖）中描述的覆盖机制，Horizon能够将这些额外信息显示为自定义列。 例如，如果Keystone中的用户具有属性phone_num，则可以定义新列： 12345678910111213from django.utils.translation import ugettext_lazy as _from horizon import formsfrom horizon import tablesfrom openstack_dashboard.dashboards.identity.users import tables as user_tablesfrom openstack_dashboard.dashboards.identity.users import viewsclass MyUsersTable(user_tables.UsersTable): phone_num = tables.Column(&apos;phone_num&apos;, verbose_name=_(&apos;Phone Number&apos;), form_field=forms.CharField(),) class Meta(user_tables.UsersTable.Meta): columns = (&apos;name&apos;, &apos;description&apos;, &apos;phone_num&apos;)views.IndexView.table_class = MyUsersTable 七、自定义Angular dashboards(对Angular不熟，这部分没有验证)在Angular中，你可以编写一个插件来扩展某些功能。Horizon框架中实现此功能的两个组件是可扩展性服务和资源类型注册表服务。extensibleService允许动态扩展某些Horizon元素，包括添加、删除和替换。resourceTypeRegistry服务提供了设置和获取与资源类型对象有关的信息的方法。我们使用像OS::Glance::Image这样的Heat类型名作为我们的参考名称。你可以在注册表中放置的一些信息包括： 用于从中获取数据的API 属性名 动作（例如“创建卷”） 详细视图或详细信息的URL路径 属性信息，如标签或属性值的格式 注册表中的这些属性使用可扩展性服务（从Newton版本开始）： globalActions batchActions itemActions detailViews tableColumns filterFacets 使用注册表中的信息，我们可以构建dashboard panel。panel使用高级指令hzResourceTable替换常用模板，因此我们不需要编写HTML和控制器代码。它为开发人员提供了一种快速构建新表或更改现有表的方法。注意：你仍然可以选择使用HTML模板来完全控制表单和功能。 例如，你可能想要创建自定义页脚。 你也可以直接使用hzDynamicTable指令（hzResourceTable在引擎盖下使用）。 但是，这些都不是可扩展的。 你需要完全覆盖面板。这是一个示例模块文件，用于演示如何对Images Panel进行一些自定义：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748(function() &#123; &apos;use strict&apos;; angular .module(&apos;horizon.app.core.images&apos;) .run(customizeImagePanel); customizeImagePanel.$inject = [ &apos;horizon.framework.conf.resource-type-registry.service&apos;, &apos;horizon.app.core.images.basePath&apos;, &apos;horizon.app.core.images.resourceType&apos;, &apos;horizon.app.core.images.actions.surprise.service&apos; ]; function customizeImagePanel(registry, basePath, imageResourceType, surpriseService) &#123; // get registry for ``OS::Glance::Image`` registry = registry.getResourceType(imageResourceType); // replace existing Size column to make the font color red var column = &#123; id: &apos;size&apos;, priority: 2, template: &apos;&lt;a style=&quot;color:red;&quot;&gt;&#123;$ item.size | bytes $&#125;&lt;/a&gt;&apos; &#125;; registry.tableColumns.replace(&apos;size&apos;, column); // add a new detail view registry.detailsViews .append(&#123; id: &apos;anotherDetailView&apos;, name: gettext(&apos;Another Detail View&apos;), template: basePath + &apos;demo/detail.html&apos; &#125;); // set a different summary drawer template registry.setSummaryTemplateUrl(basePath + &apos;demo/drawer.html&apos;); // add a new global action registry.globalActions .append(&#123; id: &apos;surpriseAction&apos;, service: surpriseService, template: &#123; text: gettext(&apos;Surprise&apos;) &#125; &#125;); &#125;&#125;)(); 此外，你应该在detail.html和drawer.html中定义内容，并定义基于actions指令和允许的需求并执行定义的方法的surpriseService。 八、IconsHorizon使用Font Awesome中的字体图标。 有关如何在代码中使用图标的说明，请参阅Font Awesome。 要向“Table Action”添加图标，请使用图标属性。 例：1234class CreateSnapshot(tables.LinkAction): name = &quot;snapshot&quot; verbose_name = _(&quot;Create Snapshot&quot;) icon = &quot;camera&quot; 此外，可以通过将ACTION_CSS_CLASSES设置为你希望在local_settings.py文件中的所有操作按钮上显示的类的元组来配置站点范围的默认按钮类。 九、自定义CSS样式表可以为dashboard定义自定义样式表。Horizon的基本模板openstack_dashboard/templates/base.html定义了可以覆盖的多个块。 要定义仅适用于特定dashboard的自定义css文件，请在dashboard的模板文件夹中创建基本模板，该文件夹可扩展Horizon的基本模板，例如 openstack_dashboard/dashboards/my_custom_dashboard / templates/my_custom_dashboard/base.html。 在此模板中，重新定义css块。（不要忘记包含_stylesheets.html，其中包括所有Horizon的默认样式表。）： 12345678910&#123;% extends &apos;base.html&apos; %&#125;&#123;% block css %&#125; &#123;% include &quot;_stylesheets.html&quot; %&#125; &#123;% load compress %&#125; &#123;% compress css %&#125; &lt;link href=&apos;&#123;&#123; STATIC_URL &#125;&#125;my_custom_dashboard/scss/my_custom_dashboard.scss&apos; type=&apos;text/scss&apos; media=&apos;screen&apos; rel=&apos;stylesheet&apos; /&gt; &#123;% endcompress %&#125;&#123;% endblock %&#125; 然后，在openstack_dashboard/dashboards/my_custom_dashboard/static/my_custom_dashboard/scss/my_custom_dashboard.scss中自定义样式表。 所有dashboard的模板都必须从自定义dashboard中base.html继承： 12&#123;% extends &apos;my_custom_dashboard/base.html&apos; %&#125;... 十、自定义Javascript与添加自定义css（参见上文）类似，可以包含自定义javascript文件。 所有Horizon的javascript文件都列在openstack_dashboard/template/horizon/_scripts.html模板中，该模板包含在的Horizon基本模板js块中。 要添加自定义javascript文件，在openstack_dashboard/dashboards/my_custom_dashboard/templates/my_custom_dashboard/_scripts.html中创建，该模板扩展了horizon/_scripts.html。在此模板中覆盖包含你的自定义JavaScript文件的块custom_js_files： 12345&#123;% extends &apos;horizon/_scripts.html&apos; %&#125;&#123;% block custom_js_files %&#125; &lt;script src=&apos;&#123;&#123; STATIC_URL &#125;&#125;my_custom_dashboard/js/my_custom_js.js&apos; type=&apos;text/javascript&apos; charset=&apos;utf-8&apos;&gt;&lt;/script&gt;&#123;% endblock %&#125; 在dashboard自定义的基本模板中，openstack_dashboard/dashboards/ my_custom_dashboard/templates/my_custom_dashboard/base.html覆盖或包含自定义的_scripts.html的js块： 123&#123;% block js %&#125; &#123;% include &quot;my_custom_dashboard/_scripts.html&quot; %&#125;&#123;% endblock %&#125; 是一个压缩的js文件，包含Horizon和dashboard的自定义脚本。此外, 在一些情况下需要将它们放在标记。为此, 请将它们放在 horizon/_custom_head_js.html文件中。与上面提到的_scrips.html文件类似： 1&lt;script src=&apos;&#123;&#123; STATIC_URL &#125;&#125;/my_custom_dashboard/js/my_marketing_js.js&apos; type=&apos;text/javascript&apos; charset=&apos;utf-8&apos;&gt;&lt;/script&gt; 或者可以将脚本直接粘贴到文件中，确保使用适当的标签 123&lt;script type=&quot;text/javascript&quot;&gt;//some javascript&lt;/script&gt; 十一、自定义元属性要将自定义元数据属性添加到项目的基本模板，请将它们包含在horizon/_custom_meta.html文件中。此文件的内容将在默认Horizon元数据属性标记之后插入到页面的中]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2018112201]]></title>
      <url>%2F2018%2F11%2F22%2F2018112201-1%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Horizon构建Dashboard]]></title>
      <url>%2F2018%2F11%2F22%2F2018112201%2F</url>
      <content type="text"><![CDATA[使用Horizon构建Dashboard一、写在前面继上篇博文，在这篇博文中举例说明扩展一个dashboard 以及 panel。类似这样的博文在网上较多，这里仅仅是回忆下，好久没有跟进OpenStack Horizon版本的代码，基于目前OpenStack rocky版本。 邮箱地址：jpzhang.ht@gmail.com个人博客：https://jianpengzhang.github.io/CSDN博客：http://blog.csdn.net/u011521019Horizon 原文阅读地址：https://docs.openstack.org/horizon/latest/contributor/tutorials/dashboard.html ￼# 二、新建Dashboard &amp; Panel按照惯例，这里简单介绍下Horizon的目录结构，至于如何构建一个Horizon的开发环境这里不在详述，这里是基于devstack部署的all in one 简单环境。#### Horizon设计和架构的核心价值： 核心支持：对所有核心OpenStack项目提供开箱即用的支持； 可扩展性：任何开发者都能增加组件； 易于管理：架构和代码易于管理，浏览方便； 视图一致：各组件的界面和交互模式保持一致； 可兼容性：API向后兼容； 易于使用：界面用户友好；#### Horizon 结构：Horizon提供一个模块化的基于Web的图形界面，采用了Django框架。Horizon目录结构主要分为两个：Horizon、opendtack_dashboard，Horizon模块的实现充分利用了很多Django框架提供的一些高级特性。如果把horizon目录中的各种实现当作积木，那么搭好的小房屋就放在openstack_dashboard的目录下。目录源码结构如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980.├── horizon # horizon通用组件库│ ├── base.py # 定义了horizon模块中从HorizonSite到Panel的各种组件的类库，并且用类HorizonSite为整个项目实例化了一个horizon对象│ ├── browsers # 浏览器基类│ ├── conf # 配置文件│ ├── context_processors.py # 自动设置相应上下文变量来解析模板的上下文处理器，他把HORIZON_CONFIG字典自动加到了Context上下文变量中传给模板│ ├── contrib # 多语言映射关系│ ├── decorators.py # 用于方便取得网页请求的当前组件和权限认证│ ├── exceptions.py # 异常处理│ ├── forms # form表单基类包│ ├── hacking│ ├── __init__.py│ ├── karma.conf.js│ ├── loaders.py # 帮助horizon模块使用自定义的方式加载模板而非使用Django自带的模板加载器│ ├── locale # 国际化语言包│ ├── management # manage.py命令的startdash/startpanel命令选项│ ├── messages.py # 消息通信│ ├── middleware # 中间件，用来处理收到的异常和网页请求及回应需要的附加的动作│ ├── notifications.py│ ├── __pycache__│ ├── site_urls.py # URL相关│ ├── static # 静态文件包│ ├── tables # table基类包│ ├── tabs # tab基类包│ ├── templates # 模板文件基类│ ├── templatetags # 模板标签基类│ ├── test # 测试包│ ├── themes.py│ ├── utils # 实用工具包│ ├── version.py # 版本信息│ ├── views.py # 视图│ └── workflows # 工作流机制包├── openstack_dashboard # horizon各个面板的具体实现代码│ ├── api # 与外部api交互的方法和接口对象│ ├── conf # nova、cinder等API访问权限控制，叫 xxx_policy.json，里面定义了鉴权用的rules│ ├── context_processors.py # 上下文处理器│ ├── contrib│ ├── dashboards # Horizon界面展示各个模块实现目录│ │ ├── admin # 管理员界面，管理登录后可见，左侧的管理员面板│ │ │ ├── instances # 云主机管理界面│ │ │ │ ├── forms.py # form表单实现│ │ │ │ ├── __init__.py│ │ │ │ ├── panel.py # 在应用程序中注册面板并定义面板属性│ │ │ │ ├── __pycache__│ │ │ │ ├── tables.py # table实现│ │ │ │ ├── tabs.py # tab实现│ │ │ │ ├── templates # 云主机html界面模板│ │ │ │ ├── tests.py # 测试│ │ │ │ ├── urls.py # url映射，描述了当浏览器网址指向那一级目录│ │ │ │ └── views.py # url映射的视图，包含页面的业务逻辑，该文件里的函数通常叫做视图│ │ │ ├── dashboard.py # 使用Horizon注册应用程序并设置dashboard属性│ │ ├── identity # 项目、用户管理界面│ │ ├── __init__.py│ │ ├── project # 普通用户登录后看到的项目面板│ │ ├── __pycache__│ │ ├── settings # 设置界面，右上角的设置面板，里面可设置语言、时区、更改密码│ ├── django_pyscss_fix│ ├── enabled # 控制导航加载哪些模块显示出来│ ├── exceptions.py # 异常处理│ ├── hooks.py│ ├── __init__.py│ ├── karma.conf.js│ ├── local # 本地配置文件│ ├── locale # 本地国家化语言包│ ├── management # 定义安装apache、horizon等是配置文件的模板文件│ ├── policy.py # 策略│ ├── __pycache__│ ├── settings.py # 设置│ ├── static # 静态包│ ├── templates # 模板包│ ├── templatetags # 模板标签包│ ├── test # 测试包│ ├── themes│ ├── theme_settings.py│ ├── urls.py # URL模型│ ├── usage # 概况页面资源统计实现包│ ├── utils # 工具包│ ├── views.py│ ├── wsgi # wsgi包│ └── wsgi.py 使用Horizon构建dashboard介绍如何使用Horizon中的各种组件来构建示例dashboard和带有tab的panel，该tab包含一个包含后端数据的表。【参考官方实例】 例如，我们将创建一个新的“My Dashboard”的Dashboard，其中“My Panel”的Panel具有“Instances Tab” 标签。该tab标签卡有一个表，其中包含Nova实例（instances）API提取的数据。 创建 Dashboard 快速方式 Horizon提供自定义管理命令，创建典型的Dashboard基础结构。在Horizon根目录中运行以下命令。它生成了需要的大部分样板代码： 12345678910$ mkdir openstack_dashboard/dashboards/mydashboard$ tox -e manage -- startdash mydashboard \ --target openstack_dashboard/dashboards/mydashboard$ mkdir openstack_dashboard/dashboards/mydashboard/mypanel$ tox -e manage -- startpanel mypanel \ --dashboard=openstack_dashboard.dashboards.mydashboard \ --target=openstack_dashboard/dashboards/mydashboard/mypanel 你会注意到目录mydashboard会自动填充与dashboard相关的文件，mypanel目录会自动填充与面板相关的文件。 目录结构 如果使用tree mydashboard命令列出openstack_dashboard/ dashboards中的mydashboard目录，你将看到如下所示的目录结构： 12345678910111213 .├── dashboard.py├── __init__.py├── mypanel│ ├── __init__.py│ ├── panel.py.tmpl│ ├── templates│ │ └── mypanel│ ├── tests.py.tmpl│ ├── urls.py.tmpl│ └── views.py└── templates └── mydashboard 不处理静态目录或tests.py文件,保持原样,有了其他文件和目录，我们可以继续添加我们自己的dashboard。 定义dashboard 打开dashboard.py文件,会注意到已自动生成以下代码： 12345678910111213from django.utils.translation import ugettext_lazy as _import horizonclass Mydashboard(horizon.Dashboard): name = _(&quot;My dashboard&quot;) slug = &quot;mydashboard&quot; panels = () # Add your panels here. default_panel = &apos;&apos; # Specify the slug of the dashboard&apos;s default panel.horizon.register(Mydashboard) 如果你希望dashboard名称是其他名称，则可以更改dashboard.py文件中的name属性。 例如，你可以将其更改为“My Dashboard” dashboard类通常包含name属性（dashboard的显示名称），slug属性（可由其他组件引用的内部名称），panels列表，默认panel等。 创建 panel我们将创建一个panel并将其命名为My Panel。 目录结构 如上所述，openstack_dashboard/dashboards/mydashboard下的mypanel目录应如下所示： 123456.├── __init__.py├── panel.py├── templates│ └── mypanel└── views.py 上面引用的panel.py文件具有特殊含义。在dashboard中，dashboard类的panels属性中列出的任何模块名称都将通过查找相应目录中的panel.py文件自动发现。 打开panel.py文件，自动生成的代码： 1234567891011from django.utils.translation import ugettext_lazy as _import horizonfrom openstack_dashboard.dashboards.mydashboard import dashboardclass Mypanel(horizon.Panel): name = _(&quot;My panel&quot;) slug = &quot;mypanel&quot;dashboard.Mydashboard.register(Mypanel) 如果你希望Panel名称是其他名称，则可以更改panel.py文件中的name属性。 例如，可以将其更改为”My panel”。 再次打开dashboard.py文件，在Mydashboard类上面插入以下代码。此代码定义了Mygroup类并添加了一个名为mypanel的面板： 12345 class Mydashboard(horizon.Dashboard):name = _(&quot;My Dashboard&quot;)slug = &quot;mydashboard&quot;panels = (Mygroup,) # Add your panels here.default_panel = &apos;mypanel&apos; # Specify the slug of the default panel. 完成的dashboard.py文件应如下所示: 1234567891011121314151617from django.utils.translation import ugettext_lazy as _import horizonclass Mygroup(horizon.PanelGroup): slug = &quot;mygroup&quot; name = _(&quot;My Group&quot;) panels = (&apos;mypanel&apos;,)class Mydashboard(horizon.Dashboard): name = _(&quot;Mydashboard&quot;) slug = &quot;mydashboard&quot; panels = (Mygroup, ) # Add your panels here. default_panel = &apos;mygroup&apos; # Specify the slug of the dashboard&apos;s default panel.horizon.register(Mydashboard) Tables, Tabs, and Views将从table开始，将其与tabs相结合，然后从各个部分构建我们的视图。 定义table Horizon提供了一个SelfHandlingForm DataTable类，它简化了大多数向最终用户显示数据的形式。我们只是在这里简单举例，但它具有大量的功能。在mypanel目录下创建一个tables.py文件并添加以下代码： 123456789101112131415from django.utils.translation import ugettext_lazy as _from horizon import tablesclass InstancesTable(tables.DataTable): name = tables.Column(&quot;name&quot;, verbose_name=_(&quot;Name&quot;)) status = tables.Column(&quot;status&quot;, verbose_name=_(&quot;Status&quot;)) zone = tables.Column(&apos;availability_zone&apos;, verbose_name=_(&quot;Availability Zone&quot;)) image_name = tables.Column(&apos;image_name&apos;, verbose_name=_(&quot;Image Name&quot;)) class Meta(object): name = &quot;instances&quot; verbose_name = _(&quot;Instances&quot;) 创建了一个tables.DataTable子类，并定义了我们想要检索显示的四列数据。这些列中的每一列显示的数据为Instances对象的属性，即定义的第一个属性值，verbose_name参数表示该列在table表格thead中的中文名字。 最后，我们添加了一个Meta类，描述instances表的元对象，即表示数据来自instances数据表。 定义table 动作Horizon提供了三种类型的基本操作类，可以在表的数据上使用： Action:表示可以对此表的数据执行的操作。 LinkAction:表示操作只是一个链接而不是POST表单。 FilterAction:表示表的过滤器操作的基类。 还有其他操作是基本Action类的扩展： BatchAction:对一个或多个对象执行批处理操作的表操作。此操作不应要求基于每个对象的用户输入。 DeleteAction:用于对表数据执行删除操作的表操作。 FixedFilterAction:带固定按钮的过滤器操作。 表中添加一个过滤器操作,显示包含在过滤器字段中输入的字符串的行。编辑tables.py文件: 12class MyFilterAction(tables.FilterAction): name = &quot;myfilter&quot; 上面指定的操作将默认filter_type为“query”。这意味着过滤器将使用客户端表排序。 将该操作添加到表的表操作中:1234class Meta(object): name = &quot;instances&quot; verbose_name = _(&quot;Instances&quot;) table_actions = (MyFilterAction,) 定义tabs 上面定义了一个表，可以显示数据。我们可以直接从这里看到一个view视图，但在里，我们还将使用horizon的TabGroup类，来定义一个tab，通过一个tab来显示视图。 在mypanel目录下创建一个tabs.py文件，创建一个包含一个tab的tab group： 12345678910111213141516171819202122232425262728293031323334353637383940from django.utils.translation import ugettext_lazy as _from horizon import exceptionsfrom horizon import tabsfrom openstack_dashboard import apifrom openstack_dashboard.dashboards.mydashboard.mypanel import tablesclass InstanceTab(tabs.TableTab): name = _(&quot;Instances Tab&quot;) slug = &quot;instances_tab&quot; table_classes = (tables.InstancesTable,) template_name = (&quot;horizon/common/_detail_table.html&quot;) preload = False def has_more_data(self, table): return self._has_more def get_instances_data(self): try: marker = self.request.GET.get( tables.InstancesTable._meta.pagination_param, None) instances, self._has_more = api.nova.server_list( self.request, search_opts=&#123;&apos;marker&apos;: marker, &apos;paginate&apos;: True&#125;) return instances except Exception: self._has_more = False error_message = _(&apos;Unable to get instances&apos;) exceptions.handle(self.request, error_message) return []class MypanelTabs(tabs.TabGroup): slug = &quot;mypanel_tabs&quot; tabs = (InstanceTab,) sticky = True 这个tab标签变得有点复杂。该tab用于处理上面定义的数据表(及其所有相关特性)，并且还使用preload属性指定默认情况下不应加载此tab，相反，当有人单击它时，它将通过AJAX加载，在大多数情况下节省了API调用的时间。 此外，表的显示由一个可重用的模板horizon/common/_detail_table.html处理。添加了一些简单的分页代码来处理大量实例列表。 最后，介绍了horizon中错误处理的机制，即是异常捕捉。horizon.exceptions.handle（）函数是一种集中式错误处理机制，它可以处理来自API的异常的所有错误以及不一致。 在视图中将它们添加上去打开views.py文件，自动生成的代码如下所示： 12345678910from horizon import views class IndexView(views.APIView): # A very simple class-based view... template_name = &apos;mydashboard/mypanel/index.html&apos; def get_data(self, request, context, *args, **kwargs): # Add data to the context here... return context 在本例中:导入正确的包后，已完成的views.py文件现在如下所示： 12345678910111213from horizon import tabs from openstack_dashboard.dashboards.mydashboard.mypanel \ import tabs as mydashboard_tabs class IndexView(tabs.TabbedTableView): tab_group_class = mydashboard_tabs.MypanelTabs template_name = &apos;mydashboard/mypanel/index.html&apos; def get_data(self, request, context, *args, **kwargs): # Add data to the context here... return context 创建 URLs自动生成的urls.py文件如下：12345678from django.conf.urls import urlfrom openstack_dashboard.dashboards.mydashboard.mypanel import viewsurlpatterns = [ url(r&apos;^$&apos;, views.IndexView.as_view(), name=&apos;index&apos;),] 创建 template在mydashboard/mypanel/templates/mypanel目录中创建/打开index.html文件：123456789101112131415&#123;% extends &apos;base.html&apos; %&#125;&#123;% load i18n %&#125;&#123;% block title %&#125;&#123;% trans &quot;My Panel&quot; %&#125;&#123;% endblock %&#125;&#123;% block page_header %&#125; &#123;% include &quot;horizon/common/_page_header.html&quot; with title=_(&quot;My Panel&quot;) %&#125;&#123;% endblock page_header %&#125;&#123;% block main %&#125;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &#123;&#123; tab_group.render &#125;&#125; &lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; 这里提供了自定义页面标题，并呈现了视图提供的tab组。 接下去将它集成到我们的OpenStack Dashboard站点中。 启用并显示dashboard为了使My Dashboard与Project或Admin等现有dashboard一起显示，需要在openstack_dashboard/enabled下创建一个名为_50_mydashboard.py的文件，并添加以下内容： 运行1tox -e runserver -- 0.0.0.0:9000]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[可插拔Panels 和 Groups]]></title>
      <url>%2F2018%2F11%2F16%2F2018111501%2F</url>
      <content type="text"><![CDATA[一、介绍Horizon允许添加dashboards(仪表板)，panels(面板)和panel groups(面板组)，而无需修改默认设置。 可插入设置是一种允许将设置存储在单独文件中的机制。 这些文件在启动时读取并用于修改默认设置。该博文基于OpenStack rocky版本。 dashboards(仪表板)配置文件的默认位置是openstack_dashboard/enabled，另一个目录是openstack_dashboard/local/enabled，用于本地覆盖。启动后将加载这两组文件，但openstack_dashboard/local/enabled中的设置将覆盖openstack_dashboard/enabled中的默认设置。 设置按文件名的字母顺序应用，如果同一仪表板的配置文件已启用且已启用本地local/enabled，则将使用本地名称覆盖前者。 请注意，由于python模块的名称不能以数字开头，因此文件通常以前导下划线和数字命名，以便您可以轻松控制其顺序。 该博文用于解释enabled中文件参数的定义，主要参考官方的说明，后续的博文将叙述具体的扩展的方式。 邮箱地址：jpzhang.ht@gmail.com个人博客：https://jianpengzhang.github.io/CSDN博客：http://blog.csdn.net/u011521019 ￼#### 二、常规设置建议1、General Pluggbale Settings可以在任何可插入设置文件（openstack_dashboard/enabled、openstack_dashboard/local/enabled）中使用以下键。（1）、ADD_EXCEPTIONS:要添加到HORIZON [‘exceptions’]的异常类的字典。1ADD_EXCEPTIONS = &#123;&#125; （2）、ADD_INSTALLED_APPS：要添加到INSTALLED_APPS的应用程序列表。 这是从插件中公开静态文件所必需的。1ADD_INSTALLED_APPS = [&apos;openstack_dashboard.dashboards.project&apos;] (3)、ADD_ANGULAR_MODULES：Angular bootstraps时要加载的AngularJS模块列表。这些模块作为依赖关系添加到根Horizon应用程序范围。 (4)、ADD_JS_FILES：包含在每个页面上加载的压缩文件的javascript源文件列表。这对于ADD_ANGULAR_MODULES中引用的AngularJS模块是必需的，因此需要包含在每个页面中。1ADD_JS_FILES = [] (5)、ADD_JS_SPEC_FILES:要包含的javascript规范文件列表，以便与Jasmine规范运行器集成。 Jasmine是一个用于测试JavaScript代码的行为驱动开发框架。 (6)、ADD_SCSS_FILES:包含在每个页面上加载的压缩文件scss文件列表。建议每个仪表板使用一个scss文件，如果需要为面板添加额外的scss文件，请使用@import。123ADD_SCSS_FILES = [ &apos;dashboard/project/containers/_containers.scss&apos;,] (7)、ADD_XSTATIC_MODULES:包含javascript和scss文件的xstatic模块列表，这些文件将包含在每个页面上加载的压缩文件。ADD_XSTATIC_MODULES中指定的相关文件不需要包含在ADD_JS_FILES中。此选项需要一个元组列表，每个元组包含一个xstatic模块和一个要加载的javascript文件列表（如果有的话）。 有关更多详细信息，请查看openstack_dashboard/utils/settings.py中BASE_XSTATIC_MODULES的注释。1234ADD_XSTATIC_MODULES = [ (&apos;xstatic.pkg.foo&apos;, [&apos;foo.js&apos;]), (&apos;xstatic.pkg.bar&apos;, None),] (8)、AUTO_DISCOVER_STATIC_FILES:如果设置为True，将自动从ADD_INSTALLED_APPS中列出的每个应用程序中的静态文件夹中发现JavaScript文件和静态html模板文件。JavaScript源文件将根据命名约定进行排序：首先列出扩展名为.module.js的文件，然后列出其他JavaScript源文件。用于测试的JavaScript文件也将根据命名约定进行排序：首先列出扩展名为.mock.js的文件，然后列出扩展名为.spec.js的文件。如果还指定了ADD_JS_FILES和/或ADD_JS_SPEC_FILES，手动列在其中的文件将附加到自动发现的文件中。 (9)、DISABLED:如果设置为True，则不会将此设置文件添加到设置中。 (10)、EXTRA_STEPS:通过使用此设置，可以将额外的工作流程步骤添加到地平线(Horizon)或其他地平线(Horizon)插件中的工作流程。 在相应工作流程中定义的默认步骤之后，将显示额外步骤。这是一个字典设置。 dict的键指定了添加额外步骤的工作流程。dict的key必须与目标工作流的完整类名匹配。dict的值是一个额外步骤类的全名列表（其中模块名称和类名称必须用句点分隔）。通过EXTRA_STEPS指定的步骤将按照注册顺序显示。123456789EXTRA_STEPS = &#123; &apos;openstack_dashboard.dashboards.identity.projects.workflows.UpdateQuota&apos;: ( (&apos;openstack_dashboard.dashboards.identity.projects.workflows.&apos; &apos;UpdateVolumeQuota&apos;), (&apos;openstack_dashboard.dashboards.identity.projects.workflows.&apos; &apos;UpdateNetworkQuota&apos;), ),&#125; (11)、EXTRA_TABS:通过使用此设置，可以将额外tabs添加到在Horizon或其他Horizon插件中实现的tab group。在相应tab group中定义的默认tab后，将显示其他tab。这是一个字典设置。dict的一个键指定一个tab group，其中添加了额外的tab。key必须与目标tab group的完整类名匹配。dict的值是额外tab类的全名列表（其中模块名称和类名称必须用句点分隔）。通过EXTRA_TABS指定的tab将按照注册顺序显示。在某些情况下，可能希望指定额外tab的顺序，因为多个Horizon插件可以注册额外的tab。可以使用优先级元组和制表符类作为dict值的元素而不是额外制表符的全名来指定EXTRA_TABS中每个制表符的优先级。优先级是tab的整数，将首先显示值较低的tab。如果省略额外tab的优先级，则假定0为优先级。 示例：123456EXTRA_TABS = &#123; &apos;openstack_dashboard.dashboards.project.networks.tabs.NetworkDetailsTabs&apos;: ( &apos;openstack_dashboard.dashboards.project.networks.subnets.tabs.SubnetsTab&apos;, &apos;openstack_dashboard.dashboards.project.networks.ports.tabs.PortsTab&apos;, ),&#125; 示例（优先级）：123456EXTRA_TABS = &#123; &apos;openstack_dashboard.dashboards.project.networks.tabs.NetworkDetailsTabs&apos;: ( (1, &apos;openstack_dashboard.dashboards.project.networks.subnets.tabs.SubnetsTab&apos;), (2, &apos;openstack_dashboard.dashboards.project.networks.ports.tabs.PortsTab&apos;), ),&#125; (12)、UPDATE_HORIZON_CONFIG:将替换HORIZON_CONFIG中的值的字典。 2、Dashboards的可插拔设置以下键专用于注册Dashboards：(1)、DASHBOARD：要添加到 HORIZON[‘dashboards’] 的仪表板的参数，必填。 (2)、DEFAULT：如果设置为True，则此仪表板将设置为默认仪表板。示例：要在本地禁用仪表板，请使用以下内容创建文件openstack_dashboard/local/enabled/_40_dashboard-name.py：12DASHBOARD = &apos;&lt;dashboard-name&gt;&apos;DISABLED = True 要添加Tuskar-UI（基础结构）仪表板，必须安装它，然后创建一个文件openstack_dashboard/local/enabled/_50_tuskar.py1234567891011from tuskar_ui import exceptionsDASHBOARD = &apos;infrastructure&apos;ADD_INSTALLED_APPS = [ &apos;tuskar_ui.infrastructure&apos;,]ADD_EXCEPTIONS = &#123; &apos;recoverable&apos;: exceptions.RECOVERABLE, &apos;not_found&apos;: exceptions.NOT_FOUND, &apos;unauthorized&apos;: exceptions.UNAUTHORIZED,&#125; 3、Panels的可插拔设置以下键专用于注册或删除面板。(1)、PANEL:要添加到HORIZON_CONFIG的PANEL。必须。 (2)、PANEL_GROUP:PANEL所关联的面板组的slug。如果希望面板在没有面板组的情况下显示，请使用面板组“default”。 (3)、DEFAULT_PANEL:如果设置，它将更新PANEL_DASHBOARD的默认面板。 (4)、ADD_PANEL:要添加的PANEL的Python面板类。 (5)、REMOVE_PANEL:如果设置为True，则PANEL将从PANEL_DASHBOARD/PANEL_GROUP删除。示例：要在管理仪表板的“管理”面板组中添加新面板，请创建一个文件openstack_dashboard/local/enabled/_60_admin_add_panel.py，其中包含以下内容1234PANEL = &apos;plugin_panel&apos;PANEL_DASHBOARD = &apos;admin&apos;PANEL_GROUP = &apos;admin&apos;ADD_PANEL = &apos;test_panels.plugin_panel.panel.PluginPanel&apos; 要在本地管理仪表板的“管理”面板组中删除“信息”面板，请创建一个文件openstack_dashboard/local/enabled/_70_admin_remove_panel.py，其中包含以下内容 1234PANEL = &apos;info&apos;PANEL_DASHBOARD = &apos;admin&apos;PANEL_GROUP = &apos;admin&apos;REMOVE_PANEL = True 要将Admin仪表板的默认面板更改为Instances面板，请使用以下内容创建openstack_dashboard/local/enabled/_80_admin_default_panel.py 文件： 1234PANEL = &apos;instances&apos;PANEL_DASHBOARD = &apos;admin&apos;PANEL_GROUP = &apos;admin&apos;DEFAULT_PANEL = &apos;instances&apos; 4、Panel Groups的可插拔设置以下键专用于注册面板组。(1)、PANEL_GROUP:要添加到HORIZON_CONFIG的面板组的slug。需要。 (2)、PANEL_GROUP_NAME:PANEL_GROUP的显示名称。需要。 (3)、PANEL_GROUP_DASHBOARD:PANEL_GROUP与之关联的仪表板的slug。需要。 (4)、要将新面板组添加到管理仪表板，请使用以下内容创建文件openstack_dashboard/local/enabled/_90_admin_add_panel_group.py：123PANEL_GROUP = &apos;plugin_panel_group&apos;PANEL_GROUP_NAME = &apos;Plugin Panel Group&apos;PANEL_GROUP_DASHBOARD = &apos;admin&apos;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OpenStack Ocata Horizon 开发（一）—— 快速开始]]></title>
      <url>%2F2017%2F05%2F18%2F2017051801%2F</url>
      <content type="text"><![CDATA[一、写在前面这篇文章主要介绍了OpenStack Ocata Horizon 根据官方的快速开始文档进行实际的调试验证，涉及在基于基本组件部署完成的情况下，源码部署Horizon开发环境，在后续的文章中将通过不同的文章来具体来说明开发，不涉及OpenStack Ocata 其他组件部署，由于作者能力或者理解不够如果错误请告知， 如果转载，请保留作者信息。 邮箱地址：jpzhang.ht@gmail.com个人博客：https://jianpengzhang.github.io/CSDN博客：http://blog.csdn.net/u011521019 ￼### 二、Horizon (OpenStack Dashboard)Horizon是一个基于Django的项目，旨在提供一个完整的OpenStack仪表板，以及一个可扩展框架，用于从可重用组件来构建新的仪表板。 openstack_dashboard模块是Django站点的实现，它使用Horizon APP来提供与各种OpenStack项目基于Web的交互。项目页面：https://launchpad.net/horizon蓝图和功能规格：https://blueprints.launchpad.net/horizon问题跟踪：https://bugs.launchpad.net/horizon源代码:https://github.com/openstack/horizon代码审查:https://review.openstack.org/#q,status:open+project:openstack/horizon,n,z持续集成:Jenkinshttps://jenkins.openstack.org ;Zuulhttp://status.openstack.org/zuul### 三、使用Horizon请参阅doc/source/topics/install.rst 有关如何在OpenStack中安装Horizon。 它描述了示例步骤，并提供了更详细的设置和配置的指针。也可以在http://docs.openstack.org/developer/horizon/topics/install.html上找到。Horizon界面功能使用请参考：https://docs.openstack.org/user-guide/common/conventions.html### 四、开发人员入门doc/source/quickstart.rst 或http://docs.openstack.org/developer/horizon/quickstart.html介绍如何设置Horizon开发环境并开始开发。### 五、构建贡献者文档OpenStack Horizon 源码包目录中有一个目录为：horizon-stable-ocata/doc：1234567891011121314151617.├── Makefile└── source ├── browser_support.rst ├── conf.py ├── contributing.rst ├── faq.rst ├── glossary.rst ├── images ├── index.rst ├── intro.rst ├── plugin_registry.rst ├── quickstart.rst ├── ref ├── testing.rst ├── topics └── tutorials 这里面是由贡献者撰写的关于Horizon使用的文档，与http://docs.openstack.org/developer/horizon/quickstart.html内容是一直的，如果觉得网页浏览查看速度慢或者环境限制不能上网可以通过构建成html在本地进行浏览，源文件使用reStructuredText维护在doc/source目录中，由Sphinx构建. 自动建筑命令：1$ ./run_tests.sh --docs 如果想知道更多run_tests.sh的功能，可以./run_tests.sh --help查阅，通过该方式构建文档，通过virtualenv建立一个隔离的环境。 手动建筑命令： 1$ tools / with_venv.sh sphinx-build doc / source doc/build/html目录中： 12345678910111213141516171819202122.├── browser_support.html├── contributing.html├── faq.html├── genindex.html├── glossary.html├── _images├── index.html├── intro.html├── _modules├── objects.inv├── plugin_registry.html├── py-modindex.html├── quickstart.html├── ref├── search.html├── searchindex.js├── _sources├── _static├── testing.html├── topics└── tutorials 六、Horizon UI开发环境部署这里认为你已经部署好了一个openstack ocata基础环境，仅演示手动部署horizon UI开发环境。 (1)、基础准备通过Virtualenv，创建一个隔离的horizon部署环境，pip安装virtualenv:12apt-get install python-pippip install virtualenv 或者 apt-get install python-virtualenv 创建一个独立的Horizon运行环境:123456virtualenv --no-site-packages horizon.venv输出：Running virtualenv with interpreter /usr/bin/python2New python executable in /home/work/horizon.venv/bin/python2Also creating executable in /home/work/horizon.venv/bin/pythonInstalling setuptools, pkg_resources, pip, wheel...done. source进入该环境:12source horizon.venv/bin/activate(horizon.venv) root@ubuntu:/home/work# 退出当前的venv环境，使用deactivate命令：12(horizon.venv) root@ubuntu:/home/work# deactivateroot@ubuntu:/home/work# (2)、安装 Horizon下载 Horizon 代码:12git clone https://github.com/openstack/horizon.gitcd horizon/ 安装 Horizon 用于开发:在horizon目录下执行，1pip install -e . 出错：123_setup/include/cext.h:34:20: fatal error: Python.h: No such file or directory #include &quot;Python.h&quot; 执行如下命令解决问题，在重复执行上面的命令：1sudo apt-get install -y libxml2-dev libxslt1-dev zlib1g-dev python3-pip 配置环境：1cp openstack_dashboard/local/local_settings.py.example openstack_dashboard/local/local_settings.py vi openstack_dashboard/local/local_settings.py12345678910111213141516171819202122232425262728ALLOWED_HOSTS = &apos;*&apos;# ...OPENSTACK_KEYSTONE_DEFAULT_DOMAIN = &apos;default&apos; # 如果 Domain 的 ID 不是 default，则为对应的 ID # ...OPENSTACK_KEYSTONE_MULTIDOMAIN_SUPPORT = True# ...OPENSTACK_HOST = &quot;172.16.17.59&quot; # 控制节点IP地址OPENSTACK_KEYSTONE_URL = &quot;http://%s:5000/v3&quot; % OPENSTACK_HOSTOPENSTACK_KEYSTONE_DEFAULT_ROLE = &quot;user&quot; #根据你的环境自己配置这个参数，这里我是‘user’# ...OPENSTACK_API_VERSIONS = &#123; &quot;identity&quot;: 3, &quot;image&quot;: 2, &quot;volume&quot;: 2,&#125;# ...# 根据你的网络环境配置这里的参数OPENSTACK_NEUTRON_NETWORK = &#123; #... &apos;enable_router&apos;: False, &apos;enable_quotas&apos;: False, &apos;enable_distributed_router&apos;: False, &apos;enable_ha_router&apos;: False, &apos;enable_lb&apos;: False, &apos;enable_firewall&apos;: False, &apos;enable_vpn&apos;: False, &apos;enable_fip_topology_check&apos;: False,&#125; 初始化静态文件 注意：一定要先执行此步骤再启动服务！否则再执行因为缓存还是不能正常运行，需要在 collectstatic 时增加 -c 参数123python manage.py collectstatic -lpython manage.py compress --force 启动 Horizon 项目:1python manage.py runserver 0.0.0.0:8001 出错：1AttributeError: DjangoTranslation instance has no attribute &apos;plural&apos; 执行如下命令解决问题：12cd horizon/openstack_dashboarddjango-admin compilemessages (3)、小结完成上述配置，一个简单的 OpenStack UI 开发环境就搭建完成了。当然每个人的环境不一致，可能会遇到一些奇怪的问题，需要静下心满满解决这些问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux Ubuntu 修改网卡名字]]></title>
      <url>%2F2017%2F04%2F18%2F2017041801%2F</url>
      <content type="text"><![CDATA[Linux Ubuntu 修改网卡名字一、写在前面这篇文章主要介绍了，Linux Ubuntu 系统下通过以下两种方式修改网卡的名字，这里根据自己的实际操作验证，从中学习记录，方便后续查询。 邮箱地址：jpzhang.ht@gmail.com个人博客：https://jianpengzhang.github.io/CSDN博客：http://blog.csdn.net/u011521019 ￼### 二、方案一：1,首先修改网卡物理配置文件，没有这个文件的话新建一个或者从已有的环境上拷贝一份过来按照要求进行修改&gt; vi /etc/udev/rules.d/70-persistent-net.rules1234567# PCI device 0x14e4:0x1692 (tg3)SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;bc:30:5b:b1:cd:be&quot;, ATTR&#123;dev_id&#125;==&quot;0x0&quot;, ATTR&#123;type&#125;==&quot;1&quot;, KERNEL==&quot;eth*&quot;, NAME=&quot;eth0&quot;关键字解释：ATTR&#123;address&#125;==&quot;bc:30:5b:9c:ae:79&quot; ##物理网卡MAC地址 ifconfig查看KERNEL==&quot;eth*&quot; ##原网卡名NAME=&quot;eth0&quot; ##现网卡名 需要把这个文件中网卡的MAC地址，原网卡名字以及需要改成的网卡名字配置进去。 2,修改网落配置文件 vi /etc/network/interfaces 1234567auto eth0iface eth0 inet staticaddress 172.16.19.XXnetmask 255.255.255.0这个要配置成修改后新的网卡名字auto eth0 ##网卡名对应要正确 3,重启服务器 重启物理服务器有一定的风险服务器没有重启起来，个人测试环境比较老旧有出现过服务器重启不起来，或者重启起来服务器因为网络配置错误出现失联情况，提示：在进行网卡修改的时候最好服务器离自己比较近，不要在远程的方式下进行修改，防止服务器失联。 三、方案二：在/etc/default/grub中，GRUB_CMDLINE_LINUX里添加参数net.ifnames=0 biosdevname=0，如下图所示: ￼ 然后在命令行执行，update-grub，最后，修改/etc/network/interfaces文件，将网卡名改为eth0重启系统，网卡名更改成功，当然这里也会出现服务器失联的情况需要注意。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub + Hexo 搭建个人博客]]></title>
      <url>%2F2017%2F04%2F16%2F2017041601%2F</url>
      <content type="text"><![CDATA[GitHub + Hexo 搭建个人博客一、写在前面这篇文章主要介绍了，在Ubuntu14.04系统上通过GitHub + Hexo搭建个人博客，网上已经有比较多的关于这方面的文章，这里把自己在实际搭建过程的步骤记录下来，以便以后查询。 搭建一个独立的个人博客目的是，可以将自己在工作学习中的一些知识及经验记录下来，不断积累知识，不断总结经验，同时提升自己的表述能力，让自己可以不断的进步、成长。 目前搭建独立的个人博客有很多种方式，可以选择购买云主机搭建动态博客，例如通过WordPress等，这也是我之前的方式，迫于购买云主机的成本过于高，个人收入微薄，因此考虑使用Github Pages来搭建一个静态的个人博客。 邮箱地址：jpzhang.ht@gmail.com个人博客：https://jianpengzhang.github.io/CSDN博客：http://blog.csdn.net/u011521019 ￼### 二、准备工作1、注册Github 进入Github 网站，按照提示进行注册，然后登录。￼ 登录完成之后，在你的主页点击图标 New Repository 创建一个新的版本库，因为我们是使用 Github Pages 去搭建我们的静态博客，所以版本库的名称应该是你的“用户名+.github.io”。如：我的用户名是：jianpnegzhang，那么版本库的名字应该是： jianpnegzhang.github.io ，这个是一定不能出错的。因为之后你将要访问的你的博客地址就是： https://jianpnegzhang.github.io,对于这个印象特别深，在这里踩过坑。 三、本地安装GitUbuntu:12$sudo apt-get update$sudo apt-get install git 安装完Git可以配置SSH，访问私钥及公钥，我在这里不具体讲了，可自己查阅行管配置，个人也并没有配置。 四、本地安装Node.js请进入Node.js 的官网下载安装 Node.js &gt;= 6.x： 12curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -sudo apt-get install -y nodejs Node.js v7：12curl -sL https://deb.nodesource.com/setup_7.x | sudo -E bash -sudo apt-get install -y nodejs 这里我安装的是Node.js &gt;= 6.x，你可以根据自己的需要选择安装的版本。 验证安装完成：12345root@hexo:~# nodejs -vv6.10.2root@hexo:~# npm -v3.10.10 输出以上信息即表示安装完成。 五、安装HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。 Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 Hexo的安装在其官方文档中有很详细的说明。下面将简单介绍Hexo的安装。 1、安装前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js,前面已经说明，不再赘述 Git,前面已经说明，不再赘述 安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。1$ npm install -g hexo-cli 六、建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml:网站的 配置 信息，您可以在此配置大部分的参数。package.json:应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。scaffolds:模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。source:资源文件夹是存放用户资源的地方。themes:主题 文件夹。Hexo 会根据主题来生成静态页面。 至目前为止，本地基于hexo以及默认主题的博客已经部署好了，这里我不在一一说明每个参数的配置，具体参数配置可以参考官网，这里有比较详细的说明。 本地测试运行： 12$ hexo g #生成静态页面，生成的内容在public文件夹下$ hexo s #启动本地服务，进行文章预览调试。hexo s --debug 命令可以用来调试 浏览器输入：http://ip:4000/显示hexo默认主题： 七、修改主题我这里演示使用NexT主题，下面只介绍怎么安装这种主题，其他主题可以在Hexo Theme里面寻找。12这里以克隆最新代码为例，在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码：git clone https://github.com/iissnan/hexo-theme-next themes/next 然后打开Hexo主文件夹下的_config.yml，修改其中的theme 属性。theme: 后面要加空格。 1theme: next 本地运行：12$ hexo g$ hexo s 效果： NexT 文档 - NexT的详细配置可以在这里查看。 八、部署到Github Pages先使用下面的命令对Git进行初始配置。12$ git config --global user.name &quot;your name&quot;$ git config --global user.email &quot;email@email.com&quot; 然后打开Hexo主文件夹下的_config.yml，设置其中的deploy 参数，详细请查看Hexo官方文档中部署部分。我的设置如下所示：12345deploy: type: git repo: https://github.com/jianpengzhang/jianpengzhang.github.io.git branch: master message: &apos;站点更新:&#123;&#123;now(&quot;YYYY-MM-DD HH:mm:ss&quot;)&#125;&#125;&apos; git地址建议使用SSH地址。在上面的参数设置好了之后，使用下面的命令安装 hexo-deployer-git 插件，只有安装了插件之后才可以部署到Github Pages。 1$ npm install hexo-deployer-git --save 安装完插件之后使用下面的命令进行部署： 12$ hexo g #生成静态文件$ hexo d #部署到github 还有一个更快捷的命令： 1$ hexo d -g #在部署前先生成 以下提示说明部署成功： 1[info] Deploy done: git 九、Hexo常用命令下面仅列出几种常用的命令。更详细的命令请查看Hexo官方文档。1234567891011121314hexo help #查看帮助hexo init #初始化一个目录hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成网页，可以在 public 目录查看整个网站的文件hexo server #本地预览，&apos;Ctrl+C&apos;关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹简写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 个人已经完成部署的博客：https://jianpengzhang.github.io/￼]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux cpu 详解]]></title>
      <url>%2F2017%2F03%2F19%2F2017031901%2F</url>
      <content type="text"><![CDATA[Linux cpu 详解一、写在前面这篇文章主要介绍了，Linux 系统通过cat /proc/cpuinfo 文件来查阅相关CPU 信息，例如：几个物理CPU/几核/几线程，目前这样的相关信息在网上有比较多的介绍，这里根据自己的实际操作验证，从中学习记录，方便后续查询。 邮箱地址：jpzhang.ht@gmail.com个人博客：https://jianpengzhang.github.io/CSDN博客：http://blog.csdn.net/u011521019 ￼#### 二、检查CPU信息相关命令1)、概念: 1、物理CPU:实际服务器中插槽上的CPU个数,物理cpu数量，可以数不重复的”physical id”有几个来表示。 2、逻辑CPU:/proc/cpuinfo 用来存储cpu硬件信息的信息内容分别列出了processor 0 –processor n 的规格。这里需要注意，n是逻辑cpu数,一般情况，我们认为一颗cpu可以有多核，加上intel的超线程技术(HT), 可以在逻辑上再分一倍数量的cpu core出来 逻辑CPU数量=物理cpu数量 x cpu cores 这个规格值 x 2(如果支持并开启HT)，备注一下：Linux下top查看的CPU也是逻辑CPU个数1)、检查CPU信息相关命令 CPU核数一块CPU上面能处理数据的芯片组的数量、比如现在的i5 760,是双核心四线程的CPU、而 i5 2250 是四核心四线程的CPU一般来说，物理CPU个数×每颗核数就应该等于逻辑CPU的个数，如果不相等的话，则表示服务器的CPU支持超线程技术 逻辑CPU个数1cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l 物理CPU个数： 1cat /proc/cpuinfo | grep &quot;physical id&quot; | sort -u | wc -l 每个物理CPU中Core的个数： 1cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq | awk -F: &apos;&#123;print $2&#125;&apos; 查看core id的数量,即为所有物理CPU上的core的个数： 1cat /proc/cpuinfo | grep &quot;core id&quot; | uniq | wc -l 判断是否超线程：如果有两个逻辑CPU具有相同的”core id”，那么超线程是打开的。或者siblings数目比cpu cores数目大。 每个物理CPU中逻辑CPU(可能是core, threads或both)的个数： 1cat /proc/cpuinfo | grep &quot;siblings&quot; 三、/proc/cpuinfo文件解释/proc/cpuinfo 文件包含系统上每个处理器的数据段落。/proc/cpuinfo 描述中有 6 个条目适用于多内核和超线程（HT）技术检查：processor, vendor id, physical id, siblings, core id 和 cpu cores。 /proc/cpuinfo:processor 条目包括这一逻辑处理器的唯一标识符。physical id 条目包括每个物理封装的唯一标识符。core id 条目保存每个内核的唯一标识符。siblings 条目列出了位于相同物理封装中的逻辑处理器的数量。cpu cores 条目包含位于相同物理封装中的内核数量。如果处理器为英特尔处理器，则 vendor id 条目中的字符串是 GenuineIntel。 1、拥有相同 physical id 的所有逻辑处理器共享同一个物理插座。每个 physical id 代表一个唯一的物理封装。 2、Siblings 表示位于这一物理封装上的逻辑处理器的数量。它们可能支持也可能不支持超线程（HT）技术。 3、每个 core id 均代表一个唯一的处理器内核。所有带有相同 core id 的逻辑处理器均位于同一个处理器内核上。 4、如果有一个以上逻辑处理器拥有相同的 core id 和 physical id，则说明系统支持超线程（HT）技术。 5、如果有两个或两个以上的逻辑处理器拥有相同的 physical id，但是 core id 不同，则说明这是一个多内核处理器。cpu cores 条目也可以表示是否支持多内核。 判断CPU是否64位，检查cpuinfo中的flags区段，看是否有lm标识。Are the processors 64-bit?A 64-bit processor will have lm (“long mode”) in the flags section of cpuinfo. A 32-bit processor will not. 还有一个命令可以总揽系统CPU 概况：lscpu12345678910111213141516171819202122root@compute:~# lscpuArchitecture: x86_64CPU op-mode(s): 32-bit, 64-bitByte Order: Little EndianCPU(s): 4On-line CPU(s) list: 0-3Thread(s) per core: 1Core(s) per socket: 4Socket(s): 1NUMA node(s): 1Vendor ID: GenuineIntelCPU family: 6Model: 60Stepping: 3CPU MHz: 3200.000BogoMIPS: 6400.20Virtualization: VT-xL1d cache: 32KL1i cache: 32KL2 cache: 256KL3 cache: 6144KNUMA node0 CPU(s): 0-3 socket就是主板上插cpu的槽的数目，也就是可以插入的物理CPU的个数。core就是我们平时说的“核“，每个物理CPU可以双核，四核等等。thread就是每个core的硬件线程数，即超线程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Keystone Mitaka Tenants 分页代码下载]]></title>
      <url>%2F2017%2F02%2F26%2F2017022606%2F</url>
      <content type="text"><![CDATA[您的小额赞助，鼓励作者开发更多实用的功能：扫一扫下方二维码，完成支付，并把截图发送给QQ：3477447625，将获取百度云下载密码，百度云下载地址： http://pan.baidu.com/s/1bo4iPEf￼]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OpenStack Mitaka keystone 分页（pagination）实现]]></title>
      <url>%2F2017%2F02%2F26%2F2017022605%2F</url>
      <content type="text"><![CDATA[一、写在前面这篇文章主要介绍了OpenStack Mitaka Identity (keystone) 分页的实现，实现的方式比较简单暴力(扩展Keystone API)，但目前已是作者想到的快速便捷实现的一种方式，如果各位有更优的现实方式请告知，相互进行技术交流，因为时间仓促以及个人理解有限，固有错误的地方请指出，谢谢！ 如果转载，请保留作者信息。邮箱地址：jpzhang.ht@gmail.com个人博客：https://jianpengzhang.github.ioCSDN博客：http://blog.csdn.net/u011521019代码下载：https://jianpengzhang.github.io/2017/02/26/2017022606/￼ 二、Keystone 分页历史Identity (keystone) 分页早在2013年的时候就被提出，记忆中openstack开发峰会中还专门进行了讨论，时间过的太久记不起来，也懒得查找资料来说明历史，唯独找到https://blueprints.launchpad.net/keystone/+spec/pagination-backend-support，这个页面记录着在13年的时候扩展Identity (keystone)，尽可能提高伸缩和性能被当作为一个Blueprints记录着，其中https://blueprints.launchpad.net/keystone/+spec/filtering-backend-support表示这个Blueprints在14年有一个里程碑的进展，但是从代码层面看，并没有真正实现底层代码的分页。 https://blueprints.launchpad.net/keystone/+spec/pagination说明：分页的当前状态是未知的。本该在IceHouse summit会议 “kill pagination” 但是它从未兑现。分页依旧是残留的。 https://blueprints.launchpad.net/keystone/+spec/user-list-pagination 可以看到分页在2015年-09-11重新被提出，但是通过Blueprint information没有里程碑的进展， 目前分页的三个问题：1、Marker+Limit(例如:实现“向前”分页)构建一个用户界面分页是不合适的。2、分页扩展性不好3、OpenStack提供的Api过滤功能并不是很好用。 Pagaination 反对的论点： 1.分页被滥用。例如，如果后端、配置不正确，可能需要很长的时间来满足用户通用的查询以及可能会返回大量的数据。2.分页可能会伤害用户体验。请参阅 然而这不是分页根本性的障碍，从 API 的角度，分页是必要和有用的。 三、分页实现项目列表代码分析这里通过devstack部署的Mitaka版本来进行代码分析，默认部署完成之后keystone API 接口用的是V3， 但是简单看了下代码，horizon中对项目（tenants）连最基本的分页都没有，就决定不再基于V3接口代码下来讲解，通过对V2.0接口的代码来说明，因为V2.0接口中至少简单实现了tenants的部分分页代码，基于此来说明久更加方便易懂，读者也只需要掌握了基本的思路，想扩展其他功能列表的分页也比较轻易的事情。这里就允许自己偷个懒。V3接口项目列表（已在设置中设置每页显示2条记录）：￼你可以看到设置每页显示条目根本没有起作用。 V2.0 接口项目列表（已在设置中设置每页显示2条记录）：￼对比就比较明显，使用2.0的keystone接口，至少“前进“－&gt;下一页的按钮出来，能够进行分页，但是马上你会发现只有“前进”没有“后退”，不能翻看上一页的数据，不得不说openstack中的分页真是蛋疼。如果你和我一样，默认的API接口是3，通过一下的方式就可以进行切换。 12345678/openstack_dashboard/local/local_settings.pyWEBROOT=&quot;/&quot;COMPRESS_OFFLINE=TrueOPENSTACK_KEYSTONE_DEFAULT_ROLE=&quot;Member&quot;OPENSTACK_HOST=&quot;192.168.31.235&quot;# 注意，这里一定要写2.0OPENSTACK_API_VERSIONS=&#123;&quot;identity&quot;:2.0&#125;OPENSTACK_KEYSTONE_URL=&quot;http://192.168.31.235:5000/v2.0&quot; OK，keystone配置成V2.0的接口，接下去我们就来梳理下，“向前”实现的方式。 123456/openstack_dashboard/dashboards/identity/projects/urls.pyurlpatterns = patterns( &apos;&apos;, url(r&apos;^$&apos;, views.IndexView.as_view(), name=&apos;index&apos;), ...... 通过urls路由映射，可以查看出，项目（tenants）页面请求调用的方法是views.IndexView方法。 代码有点长： 123456789101112131415161718192021222324252627282930313233343536/openstack_dashboard/dashboards/identity/projects/views.pyclass IndexView(tables.DataTableView): table_class = project_tables.TenantsTable template_name = &apos;identity/projects/index.html&apos; page_title = _(&quot;Projects&quot;) def has_more_data(self, table): # 返回True/False，table根据返回值显示是否有下一页的按钮链接 return self._more def get_data(self): tenants = [] # 获取request.GET对象中“tenant_marker”值，该值指的是当前页面最后一条tenant的ID值 marker = self.request.GET.get( project_tables.TenantsTable._meta.pagination_param, None) # 设置默认没有下一页 self._more = False # 权限判断，判断当前用户时候有identity:list_projects、list_user_projects权限， if policy.check(((&quot;identity&quot;, &quot;identity:list_projects&quot;),), self.request): domain_context = api.keystone.get_effective_domain_id(self.request) # paginate 参数用来设置是否采用分页 try: tenants, self._more = api.keystone.tenant_list( self.request, domain=domain_context, paginate=True, marker=marker) except Exception: exceptions.handle(self.request, _(&quot;Unable to retrieve project list.&quot;)) elif policy.check(((&quot;identity&quot;, &quot;identity:list_user_projects&quot;),), self.request):...... 重点关注IndexView类中的has_more_data、get_data方法：has_more_data：返回self._more值，该值根据返回的数据数量确定下一页是否有数据，如果有数据该值为True，即页面上显示“向前”，当然相对应的还有has_prev_data方法，这在下文进行扩展的时候具体说明。get_data：该方法用来获取项目（tenants）页面tables中显示的数据信息。 接下去重点看下get_data方法，其中： 1234......marker = self.request.GET.get( project_tables.TenantsTable._meta.pagination_param, None)...... 这段代码用来从request.GET对象中获取 “project_tables.TenantsTable._meta.pagination_param”，如果没有该值即返回None，那么这里代表的是什么值呢？一点点拆分这部分代码，project_tables：openstack_dashboard.dashboards.identity.projects.tables.py -&gt; class TenantsTable()该table类定义项目（tenants）页面table。_meta：指的是TenantsTable中的元类(metaclass),class Meta(object)即： 12345678910class Meta(object): name = &quot;tenants&quot; verbose_name = _(&quot;Projects&quot;) row_class = UpdateRow row_actions = (UpdateMembersLink, UpdateGroupsLink, UpdateProject, UsageLink, ModifyQuotas, DeleteTenantsAction, RescopeTokenToProject) table_actions = (TenantFilterAction, CreateProject, DeleteTenantsAction) pagination_param = &quot;tenant_marker&quot; pagination_param:即class Meta(object)中的属性，属性值是”tenant_marker”，到了这里就比较清楚了， 123456marker = self.request.GET.get( project_tables.TenantsTable._meta.pagination_param, None) 指的是： marker = self.request.GET.get(&quot;tenant_marker&quot;, None) 经过调试，marker其实获取的是用户点击下一页的时候request.GET中tenant ID值，即浏览器地址中看到的“http://192.168.31.235:8001/identity/?tenant_marker=64d50f68d69b451c8653296db25d9c86”，这个Tenant ID指的是当前页面最后一条tenant 的ID，关于这个ID有什么作用后面会具体说明。 调用api.keystone.tenant_list方法获取tenant list 数据，传入参数paginate布尔值，代码是否进行分页，返回tenants、 self._more，self._more布尔值表示是否有更多的数据需要下一页显示。 12345tenants, self._more = api.keystone.tenant_list( self.request, domain=domain_context, paginate=True, marker=marker) 调用api.keystone.tenant_list方法获取数据，代码具体如下： 1234567891011121314151617181920212223242526272829303132333435363738394041openstack_dashboard/api/keystone.py:def tenant_list(request, paginate=False, marker=None, domain=None, user=None, admin=True, filters=None): manager = VERSIONS.get_project_manager(request, admin=admin) # 获取每页显示多少条数据 page_size = utils.get_page_size(request) limit = None # 判断是否进行分页，如果分页从底层抓取数据的数据的时候夺取一条，用来判断是否还有更多的数据，用于判断是否显示下一页 if paginate: limit = page_size + 1 has_more_data = False # if requesting the projects for the current user, # return the list from the cache if user == request.user.id: tenants = request.user.authorized_tenants elif VERSIONS.active &lt; 3: # 判断keystone API 接口版本，这里使用的是2.0接口 tenants = manager.list(limit, marker) # 判断获取的数据是否比每页显示的数据多，如果获取的数据多于每页需要显示的数据，即表示还有下一页数据展示 if paginate and len(tenants) &gt; page_size: # 按照用户配置显示制定数量的数据，移除多抓取出来的一条数据 tenants.pop(-1) # 设置下一页数据显示为true， has_more_data = True # V3 API else: domain_id = get_effective_domain_id(request) kwargs = &#123; &quot;domain&quot;: domain_id, &quot;user&quot;: user &#125; if filters is not None: kwargs.update(filters) tenants = manager.list(**kwargs) return tenants, has_more_data 这里调用“tenants = manager.list(limit, marker)”，传入需要参数limit、marker。limit：每页显示几条数据，抓取数据的时候多抓取一条，用于判断是否还有更多的数据，多取一条数据的目的为了判断显示“上一页”、“下一页”。marker：这个值很有意思，这是horizon默认分页采用的原理，marker表示当前页面第一条数据或者最后一条数据的ID值，如果点击的是下一页，这个值既是当前页面最后一条记录的ID值，该值传入到keystone中，底层代码判断该条数据在数据库中的位置，下一页的数据就从这条数据所在的位置开始取，取指定数量的数据。如果点击的是上一页，这个数值表示的是当前页面第一条数据的ID，用处也是一样，用于告知底层取下一页的数据从什么位置开始取。 调用keystoneclient的代码发起request请求，获取数据： 123456789101112131415161718192021222324252627282930313233keystoneclient/v2_0/tenants.py:def list(self, limit=None, marker=None): &quot;&quot;&quot;Get a list of tenants. :param integer limit: maximum number to return. (optional) :param string marker: use when specifying a limit and making multiple calls for querying. (optional) :rtype: list of :class:`Tenant` &quot;&quot;&quot; # 组拼参数 params = &#123;&#125; if limit: params[&apos;limit&apos;] = limit if marker: params[&apos;marker&apos;] = marker query = &quot;&quot; if params: query = &quot;?&quot; + urllib.parse.urlencode(params) # NOTE(jamielennox): try doing a regular admin query first. If there is # no endpoint that can satisfy the request (eg an unscoped token) then # issue it against the auth_url. try: tenant_list = self._list(&apos;/tenants%s&apos; % query, &apos;tenants&apos;) except exceptions.EndpointNotFound: endpoint_filter = &#123;&apos;interface&apos;: auth.AUTH_INTERFACE&#125; tenant_list = self._list(&apos;/tenants%s&apos; % query, &apos;tenants&apos;, endpoint_filter=endpoint_filter) return tenant_list 这一块没什么好讲，组拼请求参数，发起GET请求至nova api，用于获取数据，没有什么好讲，每个API接口调用都是一样的。 接下来我们具体来看下keystone组件中对于tenant请求的处理， 12345678910111213keystone/keystone/assignment/routers.pyclass Public(wsgi.ComposableRouter): def add_routes(self, mapper): # 定义处理的控制器类 tenant_controller = controllers.TenantAssignment() # 映射，将通过“GET”方式以及请求地址带上“/tenants”发送的请求绑定到处理控制器tenant_controller。 mapper.connect(&apos;/tenants&apos;, controller=tenant_controller, # 指定控制器中处理的函数 action=&apos;get_projects_for_token&apos;, # 指定请求发送的方式 conditions=dict(method=[&apos;GET&apos;])) 在“Public”类中的add_routes函数中清楚的定义了，当API请求地址为“/tenants”时并且请求是以“GET”的方式发送过来，调用控制器为tenant_controller中的“get_projects_for_token”函数，tenant_controller控制器指的是controllers.TenantAssignment()，至于如何加载这个路由规则后续的文章讲逐步说明。 控制器处理函数： 12345678910111213141516171819202122232425262728/keystone/keystone/assignment/controllers.py@dependency.requires(&apos;assignment_api&apos;, &apos;identity_api&apos;, &apos;token_provider_api&apos;)class TenantAssignment(controller.V2Controller): &quot;&quot;&quot;V2 Tenant api处理类。&quot;&quot;&quot; @controller.v2_auth_deprecated def get_projects_for_token(self, context, **kw): &quot;&quot;&quot;获取基于用于认证令牌令牌有效的租户。 从上下文获取令牌，验证它并得到有效租户令牌中的用户。 &quot;&quot;&quot; token_ref = utils.get_token_ref(context) # 获取tenant 列表 tenant_refs = ( self.assignment_api.list_projects_for_user(token_ref.user_id)) # project_ref从V3到V2转换， 该方法只适用于project_refs从2.0控制器返回 # 如果ref是列表类型，我们将通过每个元素反复做转换。 tenant_refs = [self.v3_to_v2_project(ref) for ref in tenant_refs if ref[&apos;domain_id&apos;] == CONF.identity.default_domain_id] params = &#123; &apos;limit&apos;: context[&apos;query_string&apos;].get(&apos;limit&apos;), &apos;marker&apos;: context[&apos;query_string&apos;].get(&apos;marker&apos;), &#125; # 格式v2样式项目列表,包括标记/限制。 return self.format_project_list(tenant_refs, **params) 这里涉及比较重要的三个方法调用： 1、/keystone/keystone/assignment/core.py：list_projects_for_user():获取project_ref，即tenants 2、/keystone/keystone/common/controller.py：v3_to_v2_project():project_ref从V3到V2转换。 3、/keystone/keystone/common/controller.py：format_project_list()转换v2样式项目列表,包括标记/限制。 这里重点讲一下1和3， 获取project_ref，即tenants12345678910/keystone/keystone/assignment/core.py# TODO(henry-nash): We might want to consider list limiting this at some # point in the future. def list_projects_for_user(self, user_id, hints=None): assignment_list = self.list_role_assignments( user_id=user_id, effective=True) # Use set() to process the list to remove any duplicates project_ids = list(set([x[&apos;project_id&apos;] for x in assignment_list if x.get(&apos;project_id&apos;)])) return self.resource_api.list_projects_from_ids(list(project_ids)) 这个函数比较复杂，在这里不进行代码分析，后续有用到在具体进行分析，你只需要了解到，这个方法最终将返回tenants 列表。 默认分页的实现让我们回到class TenantAssignment(), 看下：1234567/keystone/keystone/assignment/controllers.py......params = &#123; &apos;limit&apos;: context[&apos;query_string&apos;].get(&apos;limit&apos;), &apos;marker&apos;: context[&apos;query_string&apos;].get(&apos;marker&apos;), &#125; return self.format_project_list(tenant_refs, **params) 这部分代码把分页用到的参数：limit、marker 、以及tenant_refs传入到self.format_project_list() 实现分页,但是可以这里知道Mitaka版本的horizon并没有在把limit、marker 参数传递过来，因此分页并没有起作用。 123456789101112131415161718192021222324252627282930313233343536373839404142keystone/keystone/common/controller.py(384)format_project_list() def format_project_list(self, tenant_refs, **kwargs): &quot;&quot;&quot;Format a v2 style project list, including marker/limits.&quot;&quot;&quot; # 获取horizon传递过来的marker值，该值表示的是上一页最后一条记录的ID值或者最后一条记录的ID值 marker = kwargs.get(&apos;marker&apos;) # 初始化下一页数据或上一个数据从什么位置开始取 first_index = 0 if marker is not None: # 循环确定marker ID表示的记录位置， for (marker_index, tenant) in enumerate(tenant_refs): if tenant[&apos;id&apos;] == marker: # we start pagination after the marker # 通过比对marker值，确定下一页数据或者上一页数据从first_index位置开始取 first_index = marker_index + 1 break else: msg = _(&apos;Marker could not be found&apos;) raise exception.ValidationError(message=msg) # limit 表示取几条记录 limit = kwargs.get(&apos;limit&apos;) last_index = None if limit is not None: try: limit = int(limit) if limit &lt; 0: raise AssertionError() except (ValueError, AssertionError): msg = _(&apos;Invalid limit value&apos;) raise exception.ValidationError(message=msg) # 确定分页取到第几条记录的位置 last_index = first_index + limit # 通过列表切片的形式进行分页，这里可以看到没有实现真正的数据库分页， # 还是一种简单的分页，这种分页比前段分页就是降低了请求返回的数据包大小 tenant_refs = tenant_refs[first_index:last_index] for x in tenant_refs: if &apos;enabled&apos; not in x: x[&apos;enabled&apos;] = True o = &#123;&apos;tenants&apos;: tenant_refs, &apos;tenants_links&apos;: []&#125; return o 具体分析可以看我的代码注释，这一块没有起到正真的分页，只是一种伪分页，没有实现数据库分页机制，在性能上并没有提升多少。 实现项目列表分页OK，说了这么多，接下来我就来讲讲怎么通过扩展API接口来实现项目组列表的分页，时间仓促以及个人理解有限，编码格式可能并不是标准规范请谅解。 Horizon:openstack_dashboard/dashboards/identity/projects/views.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class IndexView(tables.DataTableView):....def has_more_data(self, table): # author: jpzhang.ht@gmail.com # blog: http://www.smallartisan.site/ or http://blog.csdn.net/u011521019 # 返回True/False，table根据返回值显示是否有下一页的按钮链接 return self._moredef has_prev_data(self, table): # author: jpzhang.ht@gmail.com # blog: http://www.smallartisan.site/ or http://blog.csdn.net/u011521019 # 返回True/False，table根据返回值显示是否有上一页的按钮链接 return self._prev....def get_data(self):#获取prev_pagination_param，该值指的是当前页面第一条tenant的ID值 prev_marker = self.request.GET.get( project_tables.TenantsTable._meta.prev_pagination_param, None) if prev_marker is not None: marker = prev_marker else: # 获取request.GET对象中“tenant_marker”值，该值指的是当前页面最后一条tenant的ID值 marker = self.request.GET.get( project_tables.TenantsTable._meta.pagination_param, None) # 根据是否是上一页还是下一页，得到一个布尔值 reversed_order = prev_marker is not None tenants = [] # 权限判断，判断当前用户时候有identity:list_projects、list_user_projects权限， if policy.check(((&quot;identity&quot;, &quot;identity:list_projects&quot;),), self.request): domain_context = api.keystone.get_effective_domain_id(self.request) # paginate 参数用来设置是否采用分页 try: tenants, self._more, self._prev = api.keystone.tenant_list_paged( self.request, domain=domain_context, paginate=True, marker=marker, sort_dir=&apos;asc&apos;, # 排序 sort_key=&apos;id&apos;, # 排序字段 reversed_order=reversed_order) except Exception: self._prev = self._more = False exceptions.handle(self.request, _(&quot;Unable to retrieve project list.&quot;))...... 这块的代码比较简单，def has_more_data(self, table)；def has_prev_data(self, table)定义两个属性值用来表示列表是否有上一页数据还是有下一页数据，根据返回的数据长度来确定，获取N＋1条数据，其中N表示每页显示的数据，每次取数据都多取一条记录用来判断是否有上一页数据还是有下一页数据。 prev_marker／marker用来获取点击上一页或者下一页的时候URL路径上表示的project ID值，这个值用来干什么上面已有介绍，这里不再叙述。 tenant_list_paged(),这个方法是自己定义的主要用来调用keystoneclient发起request请求，向keystone获取project的数据。其中有几个参数在这个说明下： paginate:用来表示是否采用分页机制来获取数据，默认是True，采用分页。 marker:用来传递点击上一页或者下一页时，当前页面第一条或者最后一条project ID值。 sort_dir:用来指定数据库获取数据时排序，如果是点击下一页数据库获取数据排序是“acs”，上一页时“desc”排序 sort_key:用来指定排序字段，默认是project “id”值 openstack_dashboard/api/keystone.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344def tenant_list_paged(request, paginate=False, marker=None, domain=None, user=None, admin=True, filters=None, sort_key=&quot;name&quot;, sort_dir=&quot;desc&quot;, reversed_order=False): &quot;&quot;&quot; author: jpzhang.ht@gmail.com blog: http://www.smallartisan.site/ or http://blog.csdn.net/u011521019 &quot;&quot;&quot; has_more_data = False has_prev_data = False manager = VERSIONS.get_project_manager(request, admin=admin) limit = None page_size = utils.get_page_size(request) # 判断是否进行分页，如果分页从底层抓取数据的数据的时候夺取一条，用来判断是否还有更多的数据，用于判断是否显示下一页 if paginate: if reversed_order: sort_dir = &apos;desc&apos; if sort_dir == &apos;asc&apos; else &apos;asc&apos; limit = page_size + 1 # if requesting the projects for the current user, # return the list from the cache if user == request.user.id: tenants = request.user.authorized_tenants elif VERSIONS.active &lt; 3: # 判断keystone API 接口版本，这里使用的是2.0接口 tenants = manager.list_paged(limit, marker, sort_key=sort_key, sort_dir=sort_dir) # V3 API 这里主要通过V2API 来讲解，故此不对V3 API进行扩展 else: domain_id = get_effective_domain_id(request) kwargs = &#123; &quot;domain&quot;: domain_id, &quot;user&quot;: user &#125; if filters is not None: kwargs.update(filters) tenants = manager.list(**kwargs) tenants, has_more_data, has_prev_data = update_pagination( tenants, page_size, marker, sort_dir, sort_key, reversed_order) return (tenants, has_more_data, has_prev_data) 添加调用keystoneclient方法，其中： 1234if paginate: if reversed_order: sort_dir = &apos;desc&apos; if sort_dir == &apos;asc&apos; else &apos;asc&apos; limit = page_size + 1 根据paginate 和 reversed_order参数来确定获取数据时采用的排序方式。limit以及获取多少条数据。 manager.list_paged()自定义在keystoneclient的函数，用来发起request请求的函数。 update_pagination()函数，根据返回的数据长度设置has_more_data，has_prev_data属性值，如果是上一页数据，需要根据排序（“acs”／“desc”）反转排序处理，保证显示数据顺序正常，这种分页有一个弊端就是对每一个数据显示的顺序有依赖性，因为底层是用过传递过去ID来确定该条记录在数据库中的位置，以此来获取上一页或者下一页的数据。如果不怕麻烦可以通过django的Paginator分页模块，传递参数（当前页数、每页显示多少条记录）到底层进行分页，这种实现机制或更好一些，这里不再具体来说明，要实现页时比较简单。 12345678910111213141516171819202122def update_pagination(entities, page_size, marker, sort_dir, sort_key, reversed_order): has_more_data = has_prev_data = False if len(entities) &gt; page_size: has_more_data = True entities.pop() if marker is not None: has_prev_data = True # first page condition when reached via prev back elif reversed_order and marker is not None: has_more_data = True # last page condition elif marker is not None: has_prev_data = True # restore the original ordering here if reversed_order: entities = sorted(entities, key=lambda entity: (getattr(entity, &apos;id&apos;) or &apos;&apos;).lower(), reverse=(sort_dir == &apos;asc&apos;)) return entities, has_more_data, has_prev_data Keystoneclient:keystoneclient的修改比较简单，这里我们API接口用的是V2.0，因此我们只需要修改V2.0即可。keystoneclient/v2_0/tenants.py 123456789101112131415161718192021222324252627282930class TenantManager(base.ManagerWithFind):...... def list_paged(self, limit=None, marker=None, sort_key=None, sort_dir=None): &quot;&quot;&quot; author: jpzhang.ht@gmail.com blog: http://www.smallartisan.site/ or http://blog.csdn.net/u011521019 &quot;&quot;&quot; # 组拼参数 params = &#123;&#125; if limit: params[&apos;limit&apos;] = limit if marker: params[&apos;marker&apos;] = marker if sort_key: params[&apos;sort_key&apos;] = sort_key if sort_dir: params[&apos;sort_dir&apos;] = sort_dir query = &quot;&quot; if params: query = &quot;?&quot; + urllib.parse.urlencode(params) try: tenant_list = self._list(&apos;/tenants/paged%s&apos; % query, &apos;tenants&apos;) except exceptions.EndpointNotFound: endpoint_filter = &#123;&apos;interface&apos;: auth.AUTH_INTERFACE&#125; tenant_list = self._list(&apos;/tenants%s&apos; % query, &apos;tenants&apos;, endpoint_filter=endpoint_filter) return tenant_list keystoneclient 中在class TenantManager(base.ManagerWithFind)类中扩展def list_paged()函数，组拼GET请求发送的参数，以及GET请求发送的请求地址“/tenants/paged”，这个地址即为自己在keystone中自己扩展的API请求接口。 Keystone:keystone 处理tenants的逻辑代码主要放在/keystone/assignment中，本文不具体介绍keystone的目录结构以及代码逻辑，仅说明扩展接口完成tenants分页数据的展示。keystone/assignment/routers.py 12345678class Admin(wsgi.ComposableRouter): def add_routes(self, mapper): # add by jpzhang.ht@gmail.com 2016/08/20 mapper.connect(&apos;/tenants/paged&apos;, controller=tenant_controller, action=&apos;get_projects_for_token_paged&apos;, conditions=dict(method=[&apos;GET&apos;]))..... 定义请求路由映射，即请求地址为“/tenants/paged”，调用的控制器为“tenant_controller”，处理的函数为“get_projects_for_token_paged”，这里主要是请求路由与控制器处理函数建立映射关系。 在控制器中定义“get_projects_for_token_paged”处理函数:keystone/assignment/controllers.py 123456789101112131415161718192021class TenantAssignment(controller.V2Controller):@controller.v2_auth_deprecated def get_projects_for_token_paged(self, context, **kw): &quot;&quot;&quot; add by jpzhang.ht@gmail.com 2016/08/18 &quot;&quot;&quot; token_ref = utils.get_token_ref(context) params = &#123; &apos;limit&apos;: context[&apos;query_string&apos;].get(&apos;limit&apos;), &apos;marker&apos;: context[&apos;query_string&apos;].get(&apos;marker&apos;), &apos;sort_key&apos;: context[&apos;query_string&apos;].get(&apos;sort_key&apos;), &apos;sort_dir&apos;: context[&apos;query_string&apos;].get(&apos;sort_dir&apos;), &#125; tenant_refs = ( self.assignment_api.list_projects_for_user_paged(user_id=token_ref.user_id, params=params)) # tenant_refs = [self.v3_to_v2_project(ref) for ref in tenant_refs # if ref[&apos;domain_id&apos;] == CONF.identity.default_domain_id] return self.format_project_list(tenant_refs) 组拼GET过来的参数，self.assignment_api.list_projects_for_user_paged()函数过去tenants数据。 keystone/assignment/core.py 123456class Manager(manager.Manager): def list_projects_for_user_paged(self, user_id, params=None): &quot;&quot;&quot; add by jpzhang.ht@gmail.com 2016/08/20 &quot;&quot;&quot; return self.driver.list_projects_for_user_paged(user_id=user_id, params=params) 这里调用相应的driver获取数据，这里只针对sql进行扩展，对ldap、kvs不做扩展。 keystone/assignment/backends/sql.py 123456789101112131415161718192021222324class Assignment(keystone_assignment.AssignmentDriverV9):...... def list_projects_for_user_paged(self, role_id=None, user_id=None, group_ids=None, domain_id=None, project_ids=None, inherited_to_projects=None, params=None): &quot;&quot;&quot; add by jpzhang.ht@gmail.com 2016/08/18 &quot;&quot;&quot; with sql.session_for_read() as session: marker_row = None if params.has_key(&apos;marker&apos;): marker_row = session.query(Project).filter_by(id=params[&apos;marker&apos;]).first() query = session.query(Project) query = sqlalchemyutils.paginate_query(query, Project, params[&apos;limit&apos;], [params[&apos;sort_key&apos;]], marker=marker_row, sort_dir=params[&apos;sort_dir&apos;]) return query.all() 获取数据库中对应的记录，其中： 1marker_row = session.query(Project).filter_by(id=params[&apos;marker&apos;]).first() 根据传递过来的tenants id值获取这条记录在数据库中的位置，如果上一页倒序获取数据，原理简单推算下你就会明白为什么上页数据是倒序取。当然这里我写的比较暴力，之前考虑过沿用其目前的获取数据的方式，但发现最后因为上一页、下一页数据对传递过来的ID值依赖性比较强，并且“RoleAssignment”这张表tenants ID值并不是主键，将会导致根据marker值获取数据的记录将会不准，因此我这边直接去获取project这张表中的数据。重启keystone，apache即可查看分页已经实现：￼￼ 四、总结通过keystone tenant项目列表的分页，其实可以看出openstack的当前的分页现状，目前我这边方式实现分页比较暴力，如果想在其他组件上通过这种方式也是可行的例如镜像、配置模版等，不过需要经过测试是否可行，我这里就不在具体说明，如果大家有其他好的方式可以告知我，互相学习。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python 数据结构和算法]]></title>
      <url>%2F2017%2F02%2F26%2F2017022604%2F</url>
      <content type="text"><![CDATA[一、写在前面这篇文章主要介绍了python 内置的数据结构（list、set以及字典），从一些实际的场景中来说明解决方案，主要是阅读《python cookbook》时写下的阅读记录，提高自己在Python开发方面的理解，记录在这里是为了方便可以随时查阅使用。因为时间仓促以及个人理解有限，固有错误的地方请指出，谢谢！ 如果转载，请保留作者信息。邮箱地址：jpzhang.ht@gmail.com个人博客：https://jianpengzhang.github.ioCSDN博客：http://blog.csdn.net/u011521019￼ 二、将序列分解为单独的变量任何序列（或可迭代的对象）都可以通过一个简单的赋值操作作为分解为单独的变量。唯一的要求是变量的总数和结构要与序列相吻合。 例如1： 12345678910111213141516&gt;&gt;&gt; p = (1, 2)&gt;&gt;&gt; x, y = p&gt;&gt;&gt; x1&gt;&gt;&gt; y2&gt;&gt;&gt; data = [&apos;jpzhang&apos;, 88, 99, (2016, 06, 15)]&gt;&gt;&gt; name, shares, price, date = data&gt;&gt;&gt; name&apos;jpzhang&apos;&gt;&gt;&gt; date(2016, 06, 15)&gt;&gt;&gt; name, shares, price, (year, mon, day) = data&gt;&gt;&gt; day15&gt;&gt;&gt; 如果元素的数量不匹配，将会得到一个错误的提示： 12345&gt;&gt;&gt; p = (1, 2)&gt;&gt;&gt; x, y, z = pTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: need more than 2 values to unpack 例如2：除了列表元祖，还包括字符串、文件、迭代器只要是可迭代对象 123456789&gt;&gt;&gt; str = &quot;Hello World&quot;&gt;&gt;&gt; a, b, c, d, e, f, g, h, i, j, k = str&gt;&gt;&gt; a&apos;H&apos;&gt;&gt;&gt; b&apos;e&apos;&gt;&gt;&gt; g&apos;W&apos;&gt;&gt;&gt; 例如3：去除特定列表中的值,把不需要的值存放到不会用到的变量上， 123456&gt;&gt;&gt; data = [&apos;jpzhang&apos;, 88, 99, (2016, 06, 15)]&gt;&gt;&gt; _, shares, price, _ = data&gt;&gt;&gt; _(2016, 6, 15)&gt;&gt;&gt; shares88 三、从任意长度的可迭代对象中分解元素从一个可迭代对象中分解出N个元素，可迭代对象的长度可能超过N，实现方式，通过Python的“＊表达式”，例如：需要python3支持，python2.7不支持 123456789101112131415161718#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;import numpydef avg(l): return float(sum(l))/max(len(l),1)def drop_first_last(grades): # first, *middle, last = grades --- python3.0 middle = grades[1:-1] # --- python2.7 return numpy.mean(middle) # or def avg()if __name__ == &apos;__main__&apos;: grades = [1, 2, 3, 4, 5] grades_avg = drop_first_last(grades) print grades_avg 四、保留最后N个元素在迭代或者是其他形式的处理过程中对最后几项记录做一个有限的历史纪录统计。例如：下面的代码对一系列文本行做简单的文本匹配操作，当发现有匹配（python）字符数时就输出当前的匹配行，以及最近前面检查过的N行文本。 1234567891011121314151617181920212223#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;__sites__ = &apos;http://www.smallartisan.site/&apos;from collections import dequedef search(lines, pattern, history=5): previons_line = deque(maxlen=history) for line in lines: if pattern in line: yield line, previons_line previons_line.append(line)# Example use on a fileif __name__ == &apos;__main__&apos;: with open(&apos;./somefile.txt&apos;) as f: for line, prevlines in search(f, &apos;python&apos;, 5): for pline in prevlines: print(pline, &quot;end=&apos;&apos;&quot;) print(line, &quot;end=&apos;&apos;&quot;) print(&apos;-&apos;*20) yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator，调用 search() 不会执行 search() 函数，而是返回一个 iterable 对象！在 for 循环执行时，每次循环都会执行 search() 函数内部的代码，执行到 yield line, previons_line 时，fab 函数就返回一个迭代值，下次迭代时，代码从 yield line, previons_line 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 yield。 如同上面的代码片段所做的一样，当编写搜索某项纪录的代码时，通常会用到含有yield关键字的生成器迭代函数。这将处理搜索过程的代码和使用搜索结果的代码成功解耦开来。 deque(maxlen=N) 创建了一个固定长度的队列，当有新的记录加入而队列已满时会自动移动除最老的那条记录。例如： 12345678910111213&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; q = deque(maxlen=3)&gt;&gt;&gt; q.append(1)&gt;&gt;&gt; q.append(2)&gt;&gt;&gt; q.append(3)&gt;&gt;&gt; qdeque([1, 2, 3], maxlen=3)&gt;&gt;&gt; q.append(4)&gt;&gt;&gt; qdeque([2, 3, 4], maxlen=3)&gt;&gt;&gt; q.append(5)&gt;&gt;&gt; qdeque([3, 4, 5], maxlen=3) 虽然通过列表操作（append、del）也能够完成deque的功能，但是队列的这种解决方案要更优雅的多，运行速度也将更快。如果deque不指定队列长度，将得到一个无界限的队列，可以在两端执行添加和弹出操作，例如： 12345678910111213141516&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; q = deque()&gt;&gt;&gt; q.append(1)&gt;&gt;&gt; q.append(2)&gt;&gt;&gt; q.append(3)&gt;&gt;&gt; qdeque([1, 2, 3])&gt;&gt;&gt; q.appendleft(4)&gt;&gt;&gt; qdeque([4, 1, 2, 3])&gt;&gt;&gt; q.pop()3&gt;&gt;&gt; qdeque([4, 1, 2])&gt;&gt;&gt; q.popleft()4 从队列两端添加或者弹出元素的复杂度都是O(1)。这和列表不同，当从列表的头部插入或者移除元素时，列表的复杂度为O(N) 五、找到最大或者最小的N个元素在集合中查找最大或最小的N个元素。 heapq 模块中有两个函数——nlargest()和nsmallest()——他们正是我们所需要的。例如： 123456&gt;&gt;&gt; import heapq&gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]&gt;&gt;&gt; print(heapq.nlargest(3, nums))[42, 37, 23]&gt;&gt;&gt; print(heapq.nsmallest(3, nums))[-4, 1, 2] 这两个函数都可以接受一个参数key，从而允许他们可以工作在更加复杂的数据结构之上。例如： 1234567891011&gt;&gt;&gt; import heapq&gt;&gt;&gt; phone = [&#123;&apos;name&apos;: &apos;sanxing&apos;, &apos;shares&apos;: 100, &apos;price&apos;: 100.11&#125;,... &#123;&apos;name&apos;: &apos;huawei&apos;, &apos;shares&apos;: 89, &apos;price&apos;: 99.31&#125;,... &#123;&apos;name&apos;: &apos;xiaomi&apos;, &apos;shares&apos;: 22, &apos;price&apos;: 89.11&#125;,... &#123;&apos;name&apos;: &apos;iphone&apos;, &apos;shares&apos;: 55, &apos;price&apos;: 34.11&#125;]&gt;&gt;&gt; cheap = heapq.nsmallest(3, phone, key=lambda s: s[&apos;price&apos;])&gt;&gt;&gt; cheap[&#123;&apos;price&apos;: 34.11, &apos;name&apos;: &apos;iphone&apos;, &apos;shares&apos;: 55&#125;, &#123;&apos;price&apos;: 89.11, &apos;name&apos;: &apos;xiaomi&apos;, &apos;shares&apos;: 22&#125;, &#123;&apos;price&apos;: 99.31, &apos;name&apos;: &apos;huawei&apos;, &apos;shares&apos;: 89&#125;]&gt;&gt;&gt; expensive = heapq.nlargest(3, phone, key=lambda s: s[&apos;price&apos;])&gt;&gt;&gt; expensive[&#123;&apos;price&apos;: 100.11, &apos;name&apos;: &apos;sanxing&apos;, &apos;shares&apos;: 100&#125;, &#123;&apos;price&apos;: 99.31, &apos;name&apos;: &apos;huawei&apos;, &apos;shares&apos;: 89&#125;, &#123;&apos;price&apos;: 89.11, &apos;name&apos;: &apos;xiaomi&apos;, &apos;shares&apos;: 22&#125;] 如果正在寻找最大或者最小的N个元素，且同集合中元素的总数目相比，N很小，那么下面的这些函数可以提供更好的性能。首先这些函数会在底层将数据转化成列表，且元素以堆的顺序排列。例如： 1234567891011121314&gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 37, 2]&gt;&gt;&gt; import heapq&gt;&gt;&gt; heap = list(nums)&gt;&gt;&gt; heapq.heapify(heap)&gt;&gt;&gt; heap[-4, 7, 1, 23, 8, 2, 18, 23, 42, 37, 37, 2]&gt;&gt;&gt; heapq.heappop(heap)-4&gt;&gt;&gt; heap[1, 7, 2, 23, 8, 2, 18, 23, 42, 37, 37]&gt;&gt;&gt; heapq.heappop(heap)1&gt;&gt;&gt; heapq.heappop(heap)2 当所要找的元素数量相对较小时，函数nlargest()和nsmallest()才是最合适的，如果只是简单的想找出最小或最大的元素（N＝1时），那么用min()和max()会更快。如果N和集合本身的大小差不多大，通常更快的方法是先对集合排序，然后最切片操作（例如，使用sorted(items)[:N]或者sorted(items[-N:])。 六、实现优先级队列实现一个队列，能够以给定的优先级来对元素排序，且每次pop操作时都会返回优先级最高的那个元素。 heapq模块实现了python中的堆排序，并提供了有关的方法。让用python实现排序算法有了简单的快捷的方式。 heappush():heapq.heappush(heap, item),将item压入到堆书组中heap中。如果不进行此步操作，后面的heappop失效。 heappop():heapq.heappop(heap),从堆数组heap中取出最小的值，并返回。 例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;__sites__ = &apos;http://www.smallartisan.site/&apos;import heapqclass PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def push(self, item, priority): heapq.heappush(self._queue, (-priority, self._index, item)) self._index += 1 def pop(self): return heapq.heappop(self._queue)[-1]class Item: def __init__(self, name): self.name = name def __repr__(self): return (&apos;Item %s&apos;, self.name)if __name__ == &apos;__main__&apos;: q = PriorityQueue() q.push(Item(&apos;foo&apos;), 1) q.push(Item(&apos;bar&apos;), 5) q.push(Item(&apos;spam&apos;), 4) q.push(Item(&apos;grok&apos;), 1) print q.pop().name print(&apos;---------------------&apos;) print q.pop().name print(&apos;---------------------&apos;) print q.pop().name print(&apos;---------------------&apos;) print q.pop().name 控制台输出：bar---------------------spam---------------------foo---------------------grok 第一次执行pop() 操作时返回的元素具有最高的优先级,拥有相同优先级的两个元素（foo, grok）返回顺序同他们插入到队列的顺序相同。 函数heapq.heappush()以及heapq.heappop()分别实现将元素从列表_queue中插入和移除，且保证列表中第一个元素的优先级最低。heappop()方法重视返回“最小”的元素，因此这就是让队列能够弹出真确元素的关键。此外，由于push和pop操作的复杂度都是O(logN),其中N代表堆中元素的数量，因此就算N的值很大，这些操作的效率也非常高。代码中，队列以元组（-priority, index, item）的形式组成。把priority取负指是为了让队列能够按照元素的优先级从高到低的顺序排列。这和正常的堆顺序是相反的，一般情况下堆是按从小到大的顺序排序的。变量index的作用是为了将具有相同优先级的元素以适当的顺序排列。通过维护一个不断递增的索引，元素将以他们入队列时的顺序来排列。但是，index在对具有相同优先级的元素间做比较操作时同样扮演了重要的角色。更多关于heapq的介绍请参考官方 七、在字典中将多个健映射到多个值上将健（key）映射到多个值的字典（即所谓的一键多值字典［multidict］）字典是一种关联容器，每个健都映射到一个单独的值上。如果想让健映射到 多个值，需要将这多个值保存到另一个容器列表或集合中。例如： 123456789d = &#123; &apos;a&apos;: [1, 2, 3], &apos;b&apos;: [4, 5]&#125;e = &#123; &apos;a&apos;: &#123;1, 2, 3&#125; &apos;b&apos;: &#123;4, 5&#125;&#125; 如果需要保留元素插入的顺序，就用列表，如果需要消除重复元素（且不在意他们的顺序），就用集合。 快速方便创建这样的字典，可以利用collections模块中的defaultdict类。 defaultdict的一个特点就是它会自动初始化第一个值，这样只需要关注添加的元素即可。例如： 123456789101112131415161718192021222324252627#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;__sites__ = &apos;http://www.smallartisan.site/&apos;from collections import defaultdictd = defaultdict(list)d[&apos;a&apos;].append(1)d[&apos;a&apos;].append(2)d[&apos;b&apos;].append(4)print(d)print(&apos;================================&apos;)b = defaultdict(set)b[&apos;a&apos;].add(1)b[&apos;a&apos;].add(2)b[&apos;b&apos;].add(4)print(b)控制台输出：defaultdict(&lt;type &apos;list&apos;&gt;, &#123;&apos;a&apos;: [1, 2], &apos;b&apos;: [4]&#125;)================================defaultdict(&lt;type &apos;set&apos;&gt;, &#123;&apos;a&apos;: set([1, 2]), &apos;b&apos;: set([4])&#125;) 关于defaultdict,需要注意的一个地方是，他会自动创建字典表项以待稍后的访问（即使这些表项当前在字典中还没有找到）。如果不想要这个功能，可以在普通的字典上调用setdefault方法来取代。例如： 123456789c = &#123;&#125;c.setdefault(&apos;a&apos;, []).append(1)c.setdefault(&apos;a&apos;, []).append(2)c.setdefault(&apos;b&apos;, []).append(3)print(c[&apos;a&apos;])输出：[1, 2] 构建一个一键多值字典是很容易的。但是如果试着自己对第一个值做初始化操作，这就会变的很杂论。例如： 1234567891011121314151617#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;__sites__ = &apos;http://www.smallartisan.site/&apos;from collections import defaultdictd = &#123;&#125;for key, value in pairs: if key not in d: d[key] = [] d[key].append(value)# 使用defaultdict后代码会清晰的多：d = defaultdict(list)for key, value in pairs: d[key].append(value) 八、让字典保持有序创建一个字典，并且在迭代或序列化这个字典的时候能够控制元素的顺序。控制一个字典中元素的顺序，你可以使用 collections 模块中的 OrderedDict 类。 在迭代操作的时候它会保持元素被插入时的顺序，示例如下： 1234567891011121314151617181920212223242526#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;__sites__ = &apos;http://www.smallartisan.site/&apos;from collections import OrderedDictdef ordered_dict(): d = OrderedDict() d[&apos;foo&apos;] = 1 d[&apos;bar&apos;] = 2 d[&apos;spam&apos;] = 3 d[&apos;grok&apos;] = 4 # Outputs &quot;foo 1&quot;, &quot;bar 2&quot;, &quot;spam 3&quot;, &quot;grok 4&quot; for key in d: print(key, d[key])if __name__ == &apos;__main__&apos;: ordered_dict() 控制输出：(&apos;foo&apos;, 1)(&apos;bar&apos;, 2)(&apos;spam&apos;, 3)(&apos;grok&apos;, 4) 当你构建一个映射结构以便稍后对其做序列化编码成另一种格式时，OrderedDict就显示的特别有用。例如，如果在想进行JSON编码时精确控制各字段的顺序，那么只要首先OrderedDict中构建数据就可以了。 1234&gt;&gt;&gt; import json&gt;&gt;&gt; json.dumps(d)&apos;&#123;&quot;foo&quot;: 1, &quot;bar&quot;: 2, &quot;spam&quot;: 3, &quot;grok&quot;: 4&#125;&apos;&gt;&gt;&gt; 有可能在你本地调试的时候会报错： 1234Traceback (most recent call last): File &quot;/Users/jpzhang/Documents/开发/Python/demo/python cookbook/demo06.py&quot;, line 6, in &lt;module&gt; from collections import OrderedDictImportError: cannot import name OrderedDict 网上查阅了下： 123456789101112131415161718http://stackoverflow.com/questions/14358162/funnelweb-error-cannot-import-ordereddictOrderedDict is a new class added to Python 2.7, so it is missing in your case.You can install a backport:pip install ordereddictor add that as a dependency in your buildout, and edit Plone/buildout-cache/eggs/transmogrify.webcrawler-1.2.1-py2.6.egg/transmogrify/webcrawler/webcrawler.py line 21 to change the import from:from collections import OrderedDicttotry: from collections import OrderedDictexcept ImportError: # python 2.6 or earlier, use backport from ordereddict import OrderedDictI have filed an issue in the funnelweb issue tracker to request that this is added to a future release of the package, see issue 22. OrderedDict 内部维护着一个根据键插入顺序排序的双向链表。每次当一个新的元素插入进来的时候， 它会被放到链表的尾部。对于一个已经存在的键的重复赋值不会改变键的顺序。 需要注意的是，一个 OrderedDict 的大小是一个普通字典的两倍，因为它内部维护着另外一个链表。 所以如果你要构建一个需要大量 OrderedDict 实例的数据结构的时候(比如读取100,000行CSV数据到一个 OrderedDict 列表中去)， 那么你就得仔细权衡一下是否使用 OrderedDict 带来的好处要大过额外内存消耗的影响。 九、字典的计算在字典上对数据执行各式各样的计算（比如求最小值、最大值、排序等等）例如：假设有一个字典在股票名称和价格间做了映射：为了对字典值执行有用的计算操作，通常需要使用 zip() 函数先将键和值反转过来。 比如，下面是查找最小和最大股票价格和股票值的代码： 12345min_price = min(zip(prices.values(), prices.keys()))# min_price is (10.75, &apos;FB&apos;)max_price = max(zip(prices.values(), prices.keys()))# max_price is (612.78, &apos;AAPL&apos;) 同样，要对数据排序只要使用zip() 再配合sorted()就可以了，比如： 1234prices_sorted = sorted(zip(prices.values(), prices.keys()))# prices_sorted is [(10.75, &apos;FB&apos;), (37.2, &apos;HPQ&apos;),# (45.23, &apos;ACME&apos;), (205.55, &apos;IBM&apos;),# (612.78, &apos;AAPL&apos;)] 当进行这些计算时，请注意zip() 创建了一个迭代器，它的内容只能被消费一次。例如下面的代码就是错误的： 123prices_and_names = zip(prices.values(), prices.keys())print(min(prices_and_names)) # OKprint(max(prices_and_names)) # ValueError: max() arg is an empty sequence 完整示例代码： 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;__sites__ = &apos;http://www.smallartisan.site/&apos;prices = &#123; &apos;ACME&apos;: 45.23, &apos;AAPL&apos;: 612.78, &apos;IBM&apos;: 205.55, &apos;HPQ&apos;: 37.20, &apos;FB&apos;: 10.75&#125;min_price = min(zip(prices.values(), prices.keys()))# min_price is (10.75, &apos;FB&apos;)max_price = max(zip(prices.values(), prices.keys()))# max_price is (612.78, &apos;AAPL&apos;)print(min_price)print(&apos;-----------------------------&apos;)print(max_price)print(&apos;------------sorted-----------------&apos;)prices_sorted = sorted(zip(prices.values(), prices.keys()))# prices_sorted is [(10.75, &apos;FB&apos;), (37.2, &apos;HPQ&apos;),# (45.23, &apos;ACME&apos;), (205.55, &apos;IBM&apos;),# (612.78, &apos;AAPL&apos;)]print(prices_sorted)控制台输出：(10.75, &apos;FB&apos;)-----------------------------(612.77999999999997, &apos;AAPL&apos;)------------sorted-----------------[(10.75, &apos;FB&apos;), (37.200000000000003, &apos;HPQ&apos;), (45.229999999999997, &apos;ACME&apos;), (205.55000000000001, &apos;IBM&apos;), (612.77999999999997, &apos;AAPL&apos;)] 如果你在一个字典上执行普通的数学运算，你会发现它们仅仅作用于键，而不是值。比如： 12min(prices) # Returns &apos;AAPL&apos;max(prices) # Returns &apos;IBM&apos; 这个结果并不是你想要的，因为你想要在字典的值集合上执行这些计算。 或许你会尝试着使用字典的 values() 方法来解决这个问题： 12min(prices.values()) # Returns 10.75max(prices.values()) # Returns 612.78 不幸的是，通常这个结果同样也不是你想要的。 你可能还想要知道对应的键的信息(比如那种股票价格是最低的？)。 你可以在 min() 和 max() 函数中提供 key 函数参数来获取最小值或最大值对应的键的信息。比如： 12min(prices, key=lambda k: prices[k]) # Returns &apos;FB&apos;max(prices, key=lambda k: prices[k]) # Returns &apos;AAPL&apos; 但是，如果还想要得到最小值，你又得执行一次查找操作。比如： 1min_value = prices[min(prices, key=lambda k: prices[k])] 前面的 zip() 函数方案通过将字典”反转”为(值，键)元组序列来解决了上述问题。 当比较两个元组的时候，值会先进行比较，然后才是键。 这样的话你就能通过一条简单的语句就能很轻松的实现在字典上的求最值和排序操作了。 需要注意的是在计算操作中使用到了(值，键)对。当多个实体拥有相同的值的时候，键会决定返回结果。 比如，在执行 min() 和 max() 操作的时候，如果恰巧最小或最大值有重复的，那么拥有最小或最大键的实体会返回：例如： 123456&gt;&gt;&gt; prices = &#123; &apos;AAA&apos; : 45.23, &apos;ZZZ&apos;: 45.23 &#125;&gt;&gt;&gt; min(zip(prices.values(), prices.keys()))(45.23, &apos;AAA&apos;)&gt;&gt;&gt; max(zip(prices.values(), prices.keys()))(45.23, &apos;ZZZ&apos;)&gt;&gt;&gt; 十、查找两字典的相同点有两个字典，我们想找出它们中间可能的相同的地方（相同的健、相同的值等）。 考虑两个字典： 1234567891011a = &#123; &apos;x&apos; : 1, &apos;y&apos; : 2, &apos;z&apos; : 3&#125;b = &#123; &apos;w&apos; : 10, &apos;x&apos; : 11, &apos;y&apos; : 2&#125; 要找出这两个字典中的相同之处，只需要通过keys()或者items()方法执行常见的集合操作即可。例如： 123456# Find keys in commona.keys() &amp; b.keys() # &#123; &apos;x&apos;, &apos;y&apos; &#125;# Find keys in a that are not in ba.keys() - b.keys() # &#123; &apos;z&apos; &#125;# Find (key,value) pairs in commona.items() &amp; b.items() # &#123; (&apos;y&apos;, 2) &#125; 这些类型的操作也可以用来修改或过滤掉字典中的内容，例如，假设想创建一个新的字典，其中会去掉某些健。下面是使用了字典推导式的代码示例： 123# Make a new dictionary with certain keys removedc = &#123;key:a[key] for key in a.keys() - &#123;&apos;z&apos;, &apos;w&apos;&#125;&#125;# c is &#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125; 一个字典就是一个键集合与值集合的映射关系。 字典的 keys() 方法返回一个展现键集合的键视图对象。 键视图的一个很少被了解的特性就是它们也支持集合操作，比如集合并、交、差运算。 所以，如果你想对集合的键执行一些普通的集合操作，可以直接使用键视图对象而不用先将它们转换成一个set。 字典的 items() 方法返回一个包含(键，值)对的元素视图对象。 这个对象同样也支持集合操作，并且可以被用来查找两个字典有哪些相同的键值对。 尽管字典的 values() 方法也是类似，但是它并不支持这里介绍的集合操作。 某种程度上是因为值视图不能保证所有的值互不相同，这样会导致某些集合操作会出现问题。 不过，如果你硬要在值上面执行这些集合操作的话，你可以先将值集合转换成set，然后再执行集合运算就行了。 十一、从序列中移除重复项且保持元素间顺序不变我们想去除序列中出现的重复元素，但依旧保持剩下的元素顺序不变 如果序列上的值都是可哈希（hashable）的，那么可以很简单的利用集合或者生成器来解决这个问题。比如： 12345678910111213141516#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;__sites__ = &apos;http://www.smallartisan.site/&apos;def dedupe(items): seen = set() for item in items: if item not in seen: yield item seen.add(item)if __name__ == &apos;__main__&apos;: a = [1, 5, 2, 1, 9, 1, 5, 10] b = list(dedupe(a)) print(b) 这个方法仅仅在序列中元素为 hashable 的时候才管用。 如果你想消除元素不可哈希(比如 dict 类型)的序列中重复元素的话，你需要将上述代码稍微改变一下，就像这样： 1234567891011121314151617#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;__sites__ = &apos;http://www.smallartisan.site/&apos;def dedupe(items, key=None): seen = set() for item in items: val = item if key is None else key(item) if val not in seen: yield item seen.add(val)if __name__ == &apos;__main__&apos;: a = [ &#123;&apos;x&apos;:1, &apos;y&apos;:2&#125;, &#123;&apos;x&apos;:1, &apos;y&apos;:3&#125;, &#123;&apos;x&apos;:1, &apos;y&apos;:2&#125;, &#123;&apos;x&apos;:2, &apos;y&apos;:4&#125;] print(list(dedupe(a, key=lambda d: (d[&apos;x&apos;],d[&apos;y&apos;])))) print(list(dedupe(a, key=lambda d: d[&apos;x&apos;]))) 这里的key参数指定了一个函数，将序列元素转换成 hashable 类型。如果你想基于单个字段、属性或者某个更大的数据结构来消除重复元素，第二种方案同样可以胜任。 如果你仅仅就是想消除重复元素，通常可以简单的构造一个集合。比如： 123456&gt;&gt;&gt; a = [1, 5, 2, 1, 9, 1, 5, 10]&gt;&gt;&gt; a[1, 5, 2, 1, 9, 1, 5, 10]&gt;&gt;&gt; set(a)set([1, 2, 10, 5, 9])&gt;&gt;&gt; 但是这种方式不能保证元素间的顺序不变，因此得到的结果会被打乱。前面展示的解决方案可避免出现这个问题。 对生成器的使用反映一个事实，那就是我们可能会希望这个函数尽可能的通用——不必绑定在只能对列表进行处理。比如，如果想读一个文件，去除其中重复的文本行，可以只需要这样处理： 123with open(somefile,&apos;r&apos;) as f:for line in dedupe(f): ... dedupe()函数模仿了内置函数 sorted() , min() 和 max()对key函数的使用方式 总结《python cookbook》 这本写的内容比较有实战意义，很多处理方式是我们在日常开发中会比较多的涉及，建议大家没事的时候多翻翻。在这篇文章发布之初的目的是为了记录下来方便以后自己查询，后来查到，网上已经有牛人将它翻译整理成好了，后续不会更新相关的文章，更多的信息可以在线查阅]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OpenStack Mitaka Horiozn 主题开发]]></title>
      <url>%2F2017%2F02%2F26%2F2017022603%2F</url>
      <content type="text"><![CDATA[OpenStack Mitaka Horiozn 主题开发一、写在前面这篇文章主要介绍了OpenStack Mitaka Horizo主题包的开发。这里只是说明horiozn主题包的开发逻辑，不具体阐述css、js、html文件的开发， 仅仅是说明horizon主题开发的方式，因为时间仓促以及个人理解有限，固有错误的地方请指出，后续将会不定期的完善，谢谢！如果转载，请保留作者信息。邮箱地址：jpzhang.ht@gmail.com个人博客：https://jianpengzhang.github.ioCSDN博客：http://blog.csdn.net/u011521019主题下载地址：http://www.smallartisan.site/?p=38￼ 二、环境准备注意：如果没有特殊说明，一下所有命令均是在root用户下执行。 通过devstack 部署OpenStack Mitaka单节点基础版本（nova、keystone、glance、vloume、horizon），具体如何部署可以参考我的另一片博文，部署完成之后可以看到目录结构如下：.├── cinder├── glance├── horizon├── keystone├── logs├── neutron├── nova├── noVNC├── requirements└── tempest可以看到我这里安装的所有组件的源码包，根据实际情况会有不同，以自己的的为主。这里主要介绍horizon组件theme的开发，其他组件这里不涉及，不需要关注，只要保证各个服务时运行正常即OK，后续将逐渐来说明其他的组件的开发，大家可以关注下我的博客或者最近刚建的博客，后续将同步更新,废话不多说，进入正题。拷贝一份horizon代码包： 1cp -r horizon horizon.dev 进入：cd horizon.dev通过django 自带的测试服务，运行horizon组件 12345678910python manage.py runserver 0.0.0.0:8001输出：Performing system checks...System check identified no issues (0 silenced).June 12, 2016 - 13:21:59Django version 1.8.10, using settings &apos;openstack_dashboard.settings&apos;Starting development server at http://0.0.0.0:8001/Quit the server with CONTROL-C. 如果是通过devstack部署的，通过这种方式运行起来的horizon，通过浏览器访问,浏览器将会出现如下错误： 1234567891011121314151617181920212223Page not found (404)Request Method: GETRequest URL: http://192.168.31.235:8001/dashboard/auth/login/?next=/Using the URLconf defined in openstack_dashboard.urls, Django tried these URL patterns, in this order:^$ [name=&apos;splash&apos;]^api/^home/$ [name=&apos;user_home&apos;]^i18n/js/(?P&lt;packages&gt;\S+?)/$ [name=&apos;jsi18n&apos;]^i18n/setlang/$ [name=&apos;set_language&apos;]^i18n/^jasmine-legacy/$ [name=&apos;jasmine_tests&apos;]^jasmine/.*?$^identity/^developer/^admin/^settings/^project/^auth/^dashboard\/static\/(?P&lt;path&gt;.*)$^dashboard\/media\/(?P&lt;path&gt;.*)$^500/$The current URL, dashboard/auth/login/, didn&apos;t match any of these.You&apos;re seeing this error because you have DEBUG = True in your Django settings file. Change that to False, and Django will display a standard 404 page. 你可以看到浏览器url地址栏默认跳转到了：“http://192.168.31.235:8001/dashboard/auth/login/?next=/“如果我们手动把浏览器地址栏中的/dashoboard/去除再次刷新就可以看到熟悉的horizon默认的登录界面 不用担心，这是因为horizon的配置文件配置的url里面默认根目录是从“dashboard”开始的，如果通过apache运行，就可以在apache horizon的配置中看到，默认horiozn的资源访问路径是从‘dashboard’开始，apache如下： 12345678910111213WSGIScriptAlias /dashboard /home/devstack.mitaka/horizon/openstack_dashboard/wsgi/django.wsgi WSGIDaemonProcess horizon user=stack group=stack processes=3 threads=10 home=/home/devstack.mitaka/horizon display-name=%&#123;GROUP&#125; WSGIApplicationGroup %&#123;GLOBAL&#125; SetEnv APACHE_RUN_USER stack SetEnv APACHE_RUN_GROUP stack WSGIProcessGroup horizon DocumentRoot /home/devstack.mitaka/horizon/.blackhole/ Alias /dashboard/media /home/devstack.mitaka/horizon/openstack_dashboard/static Alias /dashboard/static /home/devstack.mitaka/horizon/static RedirectMatch &quot;^/$&quot; &quot;/dashboard/&quot; 那这里我们只要修改horizon的配置，让其默认的访问路径从“/”开始即可正常。具体修改： 1234567891011121314vi horizon.dev/openstack_dashboard/local/local_settings.py找到：WEBROOT=&quot;/dashboard/&quot;修改为：WEBROOT=&quot;/&quot;cd horizon.dev/运行（静态文件压缩）：python manage.py compress输出：Found &apos;compress&apos; tags in: /home/devstack.mitaka/horizon.dev/openstack_dashboard/templates/horizon/_conf.html /home/devstack.mitaka/horizon.dev/openstack_dashboard/templates/_stylesheets.html /home/devstack.mitaka/horizon.dev/openstack_dashboard/templates/horizon/_scripts.htmlCompressing... doneCompressed 5 block(s) from 3 template(s) for 2 context(s). 重启服务：python manage.py runserver 0.0.0.0:8001再次访问浏览器地址：http://192.168.31.235:8001/这回自动跳转到：http://192.168.31.235:8001/auth/login/?next=/地址栏中没有出现“/dashboard/” 并且正常出现horizon登录界面，至此我们的开发环境准备完成，至于用什么IDE来开发，我相信每个程序员都有自己的喜好，这里我使用Sublime来开发，个人比较偏向于pycharm来开发，无奈环境安装在虚拟机中，pycharm社区版不支持远程开发，正好sublime有sftp工具能够远程通过代码进行开发，一拍即合，这里就用sublime来进行开发工作。 三、目录结构Horizon目录结构介绍，之前有一篇博文进行了专门的介绍，不了解的可以翻一翻，这里主要介绍下几个主题开发会用到的目录以及自己创建的主题包:.├── doc├── horizon├── horizon.egg-info├── openstack_dashboard├── releasenotes├── static└── tools可以看到horizon最外层有一个static静态文件目录,这个静态目录是用来干什么的呢？进入目录可以看到它的结构如下：.├── app├── auth├── bootstrap├── dashboard├── framework├── horizon├── scss└── themes 这个目录其实就是horizon界面访问的静态文件的统一入口，所有样式模版（css、js、html）都是这个目录提供的，那是不是我们开发的静态文件放在这个目录中呢，其实不然，我这个目录的文件是通过一个命名生成的，命令：python manage.py collectstatic一般我会在后面加一个 “-c” 的参数，把原先 static目录中的内容清空。大家可以通过python manage.py collectstatic －h 具体查看这个命令的功能，简单来说会把horizon目录下以及dashboard目录下所有用到的静态文件统一拷贝到这个目录中，在通过命令进行压缩，为上层提供所有的样式文件。命令：python manage.py compress horizon.dev/horizon目录，这个目录用来定义horizon组件全局的样式文件，其中包括一个static、 templates、templatetags 目录，static：存放一些静态文件CSS、 JStemplates：存放模版文件主要是html页面templatetags：定义html模版页面中出现出现的标签例如：在horizon.dev/horizon/templates/horizon/_nav_list.html { % if user|has_permissions:component % }，horizon.dev/horizon/templatetags/horizon.py中就有定义。 horizon.dev/openstack_dashboard目录，同样在这个目录下也包括static、 templates、templatetags 目录，作用和上述的一样，不过这里定义的不是全局的，可以把它当作是对horizon目录中定义的文件，在这里在做差距化的定义。 那么horion加载的同一个文件在两个地方都有的情况下回调用哪个文件，这个你可以看下django 模版调用机制，horiozn组件很好的利用了这一点，这里我也记不太清了，记忆中是先调用openstck目录中的，找不到的情况下会去horizon里面去找。好了，具体不再细聊了，接下去就开始我们定制化的开发工作。 四、bruce主题初始化进入我们的主题开发目录，通过拷贝现有的material目录结构来具体说明： 1cd horizon.dev/openstack_dashboard/themes 该目录用来存放horizon组件的所有的主题包，默认已经有两个目录包default、material 在上个版本中，已经支持主题开发，甚至在juno版本中也支持了，只是在Mitaka更加完善了这部分，如果学会了在Mitaka版本的开发原理，在juno版本中开发也是如此。默认horizon采用的是default 目录，但是可以通过dashboard界面的切换主题的按钮进行主题切换如下：￼ 拷贝一份“Material”目录为bruce目录 1cp -r material/ bruce 如果仅仅拷贝一份还是不行的，要让horizon识别，还需要在配置文件中进行配置，这里我为了方便直接修改了settings.py(你也可以修改local/local_settings.py)： 1vi horizon.dev/openstack_dashboard/settings.py 12345678910111213141516AVAILABLE_THEMES = [ ( &apos;default&apos;, pgettext_lazy(&apos;Default style theme&apos;, &apos;Default&apos;), &apos;themes/default&apos; ), ( &apos;material&apos;, pgettext_lazy(&quot;Google&apos;s Material Design style theme&quot;, &quot;Material&quot;), &apos;themes/material&apos; ), ( &apos;bruce&apos;, pgettext_lazy(&quot;Google&apos;s Material Design style theme&quot;, &quot;Bruce&quot;), &apos;themes/bruce&apos; ),] 这个时候你刷新浏览器会提示错误，需要你运行“python manage.py compress”，重新编译压缩下，那就按照提示做，运行命令： 12python manage.py compress重启： python manage.py runserver 0.0.0.0:8001 再次刷新浏览器，你就可以看到刚刚我们定义的主题bruce：￼ 切换至Bruce主题可以看到和Material一样的样式主题 Bruce从Material拷贝过来当然一样。那么如何让我们的Bruce主题成为horizon主题默认主题呢，还是一样，修改 1vi horizon.dev/openstack_dashboard/settings.py 1DEFAULT_THEME = &apos;default&apos; =&gt; DEFAULT_THEME = &apos;bruce&apos; 这个时候你清空浏览器缓存，重新登录horiozn，你就会发现horizon默认的主题采用的不是“default”而是我们定义的“bruce”。 接下来我们来具体认识下从Material拷贝过来的目录包括了哪些东西，具体有什么用。.├── static│ ├── bootstrap│ ├── horizon│ └── js│ └── _styles.scss│ └── _variables.scss│└── templates ├── auth ├── header ├── horizon └── material static（静态文件）：bootstrap：引入bootstrap目录，具体可以看看bootstrap目录中的_styles.scss、_variables.scsshorizon：引入horizon组件的静态文件包js：引入自定义的js文件_styles.scss：引入bootstrap、horizon目录中的样式文件，通过“@import “bootstrap/styles”;”其中styles指的是bootstrap目录中_styles.scss文件，同理horizon。_variables.scss：引入bootstrap、horizon目录中的定义的scss定义的变量文件，通过“@import “bootstrap/variables”;”其中variables指的是bootstrap目录中_variables.scss文件，同理horizon。 templates html模版文件：其实修改horizon的模版文件很简单，我只要按照上文中提到的horizon模版定义的路径，在自己的主题模版中再定义一遍就能覆盖，其实也不叫覆盖，就是在我的主题模版中一模一样的路径以及文件名定义一份，那么优先加载我定义的，当然前提是主题需要切换到我定义的主题上，不然还是不会加载的。以下目录的介绍不单单指的是当前主题中定义的，还包括horizon主题模版中这些目录包含的内容，如果我对这些模版有修改的需求，我只需要在这里定义一遍，切换到我定义的主题时，就能应用上。auth：horizon登录界面相关的模版文件header：horizon内页header样式文件，包括项目切换等。horizon：这个目录包括的东西比较多，包括内页左侧导航、form表单、table、model、tab等material：这里我不需要了，直接删除旧可以了 梳理了一遍，现在把bruce主题目录下面不需要的目录删除，添加自己需要的目录，具体目录结构如下：为了方便开发，我这里直接把auth、templates、horizon拷贝到bruce templates目录中，按照正常的开发来说，我需要重定制什么那么就把什么文件在主题中定义一遍，我这边为了方便直接把整个目录拷贝过来了。 12345cp -r /horizon.dev/horizon/templates/auth/cp -r /horizon.dev/openstack_dashboard/templates/header/cp -r /horizon.dev/horizon/templates/horizon/ 并且在static目录中新建了一个bruce目录用来放我的静态文件。在最外层_styles.scss、_variables.scss文件中引入bruce目录中styles、variables定义的内容。引入方式很简单，分别在最外层_styles.scss、_variables.scss文件增加以下内容： 12345_styles.scss：@import &quot;bruce/styles&quot;;_variables.scss：@import &quot;bruce/variables&quot;; 在运行命令：这里不再细说scss样式文件的开发，后续有时间在通过其他博文具体来说明。 12python manage.py collectstatic -cpython manage.py compress 把你新增的scss文件编译压缩。 最终你的目录结构看起来会是这个样子：.├── static│ ├── bootstrap│ ├── bruce│ ├── _styles.scss│ └── _variables.scss│ ├── horizon│ ├── _styles.scss│ └── _variables.scss└── templates ├── auth ├── header └── horizon 其中，在templates/horizon目录下面，我从openstack_dashboard/templates/horizon/_scripts.html文件拷贝了一份，现在你可以把你的js文件放在static/bruce/js目录中，通过_scripts.html文件加载进来，不过，通过这个文件加载的js文件时全局的，即各个页面只要按照horizon的html结构就能全部应用到，如果不想在各个页面使用，可以单独在html页面中引用，css文件也可以通过在html页面中单独引用，具体怎么引你可以看下_scripts.html引用方式即可。 五、登录界面开发之前提过，horizon登录界面的模版文件全部定义在auth目录中，现在我们简单进行开发， 打开：/themes/bruce/templates/auth/login.html 登录界面的入口文件 1234567891011121314&#123; % extends &quot;base.html&quot; % &#125;&#123; % load i18n % &#125;&#123; % block title % &#125;&#123; % trans &quot;Login&quot; % &#125;&#123; % endblock % &#125;&#123; % block body_id % &#125;splash&#123; % endblock % &#125;&#123; % block content % &#125; &#123; % include &apos;auth/_login.html&apos; % &#125;&#123; % endblock %&#125;&#123; % block footer % &#125; &#123; % include &apos;_login_footer.html&apos; % &#125;&#123; % endblock % &#125; 可以看到，这个文件继承自base.html,定义在horizon.dev/openstack_dashboard/templates目录中，base.html：文件定义了整个html的目录结构，如果你需要调整html结构，可以把这个文件复制到/themes/bruce/templates/目录中，如果登录界面的html结构和内页的结构不一样，可以重定义一个login_base.html,只要{ % extends “login_base.html” % }即可。这里同样我把这个文件复制了过来。为了说明，草率的进行了修改修改加了一个div： 12345&lt;body id=&quot;&#123; % block body_id % &#125;&#123; % endblock % &#125;&quot; ng-app=&apos;horizon.app&apos; ng-strict-di&gt; &lt;div style=&quot;background-color: #DE1426;&quot;&gt; Test &lt;/div&gt; ...... ￼可以看到生效了，看起来比较丑，哈哈，说明我们的结构修改生效了。接下来我们再来看下auth/_login.html，1234567&#123; % load i18n %&#125; &#123; % if &apos;is_modal&apos; in request.GET or &apos;is_modal&apos; in request.POST % &#125; &#123; % include &apos;auth/_login_modal.html&apos; % &#125;&#123; % else % &#125; &#123; % include &apos;auth/_login_page.html&apos; % &#125;&#123; % endif % &#125; 用样这个文件引入了_login_modal.html文件和_login_page.html文件，如果你觉的这样的引入层级太复杂了，也可以直接修改掉。 auth/_login_modal.html:定义登录表单,开开这个文件，可以看到它时继承自auth/_login_form.html文件，这个文件中详细定义了登录界面，修改如下：1234567&lt;div class=&quot;panel-heading&quot;&gt;&#123; % block login_header % &#125; &lt;h3 class=&quot;login-title&quot;&gt; &#123; % trans &apos;Log in&apos; % &#125;Hello World &lt;/h3&gt;&#123; % endblock % &#125;&lt;/div&gt; ￼简单吧，登录界面的修改就是这些auth/*.html页面中，具体就要看你需要修改成什么样子。## 五、header 修改好了，现在我们来看下登录进去之后header这块怎么来修改，同理：header html页面主要在/themes/bruce/templates/header目录中通过base.html：123&lt;div class=&apos;topbar&apos;&gt; &#123; % include &quot;header/_header.html&quot; % &#125;&lt;/div&gt; 可以得知_header.html是header模块的入口文件，打开/themes/bruce/templates/header/_header.html修改如下： 12&lt;nav class=&quot;navbar navbar-default navbar-fixed-top&quot; style=&quot;background-color: #3E3B3B;&quot;&gt;.... 效果如下：￼ 继续往下看，可以看到_header.html文件中引入 { % include “header/_brand.html” % }:没什么好讲，这个文件主要用来加载logo，如果你对logo的部署有所调整可以在这个文件中修改。 { % include “header/_context_selection.html” % }:该文件主要用来在定义项目／区域切换的样式：简单修改如下： 123&#123; % else % &#125;&lt;li class=&quot;dropdown&quot; style=&quot;background-color: #57b382;&quot;&gt;...... { % asset_img p8.png 图8 % }￼￼可以看到项目切换颜色发生了变化。在这个文件中通过{ % load context_selection % }自定义的标签引入了horizon.dev/openstack_dashboard/templatetags/context_selection.py 整个horizon项目中templatetags目录中定义的私有的django模版标签即自定义模版标签。通过引入这个文件，在_context_selection.html中使用的标签都可以在context_selection.py文件中找到他的实现。{ % show_overview % }：对应“def show_overview(context)”方法，并且可以根据这个方法得知它所使用的模版horizon.dev/openstack_dashboard/templates/context_selection/_overview.html，如果你想修改这个模版片段，原理都一样，那这个文件安相同的目录结构在我们的主题/themes/bruce/templates/context_selection/建立起来再进行修改即可，这里不再详细说明。{ % show_domain_list % }：修改原理同上{ % show_project_list % }：修改原理同上{ % show_region_list % }：修改原理同上 { % include “header/_user_menu.html” % }:主要用来显示右侧点击当前登录用户名的下拉列表框，包括帮助、主题切换、退出等功能简单修改如下： 12&#123; % else % &#125;&lt;li class=&quot;dropdown user-menu&quot; style=&quot;background-color: #57b382;&quot;&gt; 效果：￼￼ { % include “header/_region_selection.html” % }:用来定义区域选择，因为本地开发环境没有多区域，不能简单修改样式，但基本和上述一样进行修改即可。 如果你想在header下面添加面包屑，这一块horizon默认已经给我写好了一个样式，通过下面的修改很快就能实现一个简单样式的面包屑，当然样式就不咋的了，修改：/themes/bruce/templates/header/_header.html 12345......&lt;div style=&quot; margin-top: 43px; margin-left: 240px;&quot;&gt;&#123; % include &apos;horizon/common/_breadcrumb_nav.html&apos; % &#125;&lt;/div&gt;&#123; % endspaceless % &#125; ￼￼header的开发就讲到这里，其实都还比较简单。## 五、sidebar修改(侧边导航)根据/themes/bruce/templates/base.html 可知侧边导航入口文件为：{ % include ‘horizon/common/_sidebar.html’ % }12345......&#123; % block sidebar % &#125; &#123; % include &apos;horizon/common/_sidebar.html&apos; % &#125;&#123; % endblock % &#125;...... ok,我们打开/themes/bruce/templates/horizon/common/_sidebar.html 12345&#123; % load branding horizon i18n % &#125;&lt;div id=&apos;sidebar&apos; style=&quot;background: #353644;&quot;&gt; &#123; % horizon_nav % &#125;&lt;/div&gt; 那么在哪里定义了horizon_nav这个变量呢？可以看到它加载了{ % load branding horizon i18n % }，注意，这里有“horizon”这个文件指的是horizon.dev/horizon/templatetags/horizon.py，其中{ % horizon_nav % }标签通过文件中的”def horizon_nav(context):“函数方法定义，并且该函数方法指定了模版文件为horizon/_sidebar.html。如果需要对返回的数据格式有修改就需要改动这个文件，不建议直接修改，可以重构一个方法来进行修改合适。打开/themes/bruce/templates/horizon/_sidebar.html，没什么好讲都是html代码，其中导航就是通过for标签循环components变量加载出来的，直接进行修改就行了。简单的在： 1234567891011/themes/bruce/templates/horizon/common/_sidebar.html&#123; % load branding horizon i18n % &#125;&lt;div id=&apos;sidebar&apos; style=&quot;background: #43444C;&quot;&gt; &#123; % horizon_nav % &#125;&lt;/div&gt;/themes/bruce/templates/horizon/_sidebar.html在不同的&lt;li&gt;以及&lt;a&gt;便签添加了style=&quot;color: #fff&quot;style=&quot;background: #353644;&quot; 效果如下：￼￼ 六、page header 修改/themes/bruce/templates/base.html文件中包括了htmlhorizon/common/_page_header.html: 12345..... &#123; % block page_header % &#125; &#123; % include &quot;horizon/common/_page_header.html&quot; with title=page_title % &#125; &#123; % endblock % &#125; ...... 这个文件主要用来定义右侧页面用来显示当前plan名字位置区域，开打该文件：/themes/bruce/templates/horizon/common/_page_header.html 1234567891011&#123; % load i18n %&#125;&#123; % block page_header %&#125; &lt;div class=&apos;page-header&apos;&gt; &#123; % if actions %&#125; &lt;form class=&apos;actions_column pull-right&apos; action=&apos;&#123;&#123; url &#125;&#125;&apos; method=&quot;POST&quot;&gt; &#123; % csrf_token %&#125; &#123;&#123; actions &#125;&#125; &lt;/form&gt; &#123; % endif %&#125; &lt;/div&gt;&#123; % endblock %&#125; 修改为： 123456789101112131415&#123; % load i18n % &#125;&#123; % block page_header % &#125; &lt;div class=&apos;page-header&apos;&gt; &lt;div class=&quot;alert&quot; style=&quot;background-color:#bce8f1;border-color: #bce8f1;color: #31708f;&quot; role=&quot;alert&quot;&gt; BruceCloud 为您提供一种随时获取的、弹性的计算能力，这种计算能力的体现就是 &lt;em&gt;主机（Instance）&lt;/em&gt;。主机就是一台配置好了的服务器，它有您期望的硬件配置、操作系统和网络配置。通常情况下，您的请求可以在10秒到60秒的时间之内 完成，所以您完全可以动态地、按需使用计算能力。 &lt;/div&gt; &#123; % if actions % &#125; &lt;form class=&apos;actions_column pull-right&apos; action=&apos;&#123;&#123; url &#125;&#125;&apos; method=&quot;POST&quot;&gt; &#123; % csrf_token % &#125; &#123;&#123; actions &#125;&#125; &lt;/form&gt; &#123; % endif % &#125; &lt;/div&gt;&#123; % endblock % &#125; 效果：{ % asset_img p12.png 图12 % }￼￼ 六、footer 修改/themes/bruce/templates/base.html文件中包括了html_footer.html : 123&#123; % block footer % &#125; &#123; % include &quot;_footer.html&quot; % &#125;&#123; % endblock % &#125; 该文件默认放在horizon.dev/openstack_dashboard/templates/_footer.html目录下，老方法，拷贝一份到/themes/bruce/templates/目录下，打开： 123&#123; % comment % &#125; A simple placeholder template for custom global footer content&#123; % endcomment % &#125; 默认控制为不显示出来，不细究，反正比较简单。 六、messages 修改/themes/bruce/templates/base.html文件中包括了htmlhorizon/_messages.html: 1234......&lt;div id=&apos;main_content&apos; style=&quot;margin-top: -90px;&quot;&gt; &#123; % include &quot;horizon/_messages.html&quot; % &#125;...... 打开：/themes/bruce/templates/horizon/_messages.html： 12345678910&#123; % for message in messages % &#125; &#123; % if &quot;info&quot; in message.tags % &#125; &lt;div class=&quot;alert alert-info alert-dismissable fade in&quot;&gt; &lt;a class=&quot;close&quot; data-dismiss=&quot;alert&quot; href=&quot;#&quot;&gt; &lt;span class=&quot;fa fa-times&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;p&gt;&lt;strong&gt;&#123;% trans &quot;Info: &quot; % &#125;&lt;/strong&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123; % endif % &#125;...... 文件中定义不同消息类型显示的样式。需要修改的直接改这个文件就可以了。 七、project/instances修改原理很简单，在每个模块下面都有一个templates，当然不直接修改这个目录下面的模版文件，我们把整个模版目录拷贝到我们的主题模版目录下面来进行修改，例如：建立如下目录结构：horizon.dev/openstack_dashboard/themes/bruce/templates/project拷贝：cp -r ../../../../dashboards/project/instances/templates/instances/ ./好了，现在我们开始修改我们主机模版目录下面的instances模版样式文件：修改云主机下拉列表页面，打开目录：themes/bruce/templates/project/instances/index.html 123456789101112&#123; % extends &apos;base.html&apos; % &#125;&#123; % load i18n % &#125;&#123; % block title % &#125;&#123; % trans &quot;Instances&quot; % &#125;&#123; % endblock % &#125;&#123; % block main % &#125; &lt;div class=&quot;jumbotron&quot;&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;&lt;a class=&quot;btn btn-primary btn-lg&quot; href=&quot;#&quot; role=&quot;button&quot;&gt;Learn more&lt;/a&gt;&lt;/p&gt;&lt;/div&gt; &#123;&#123; table.render &#125;&#125;&#123; % endblock % &#125; 效果： ￼￼ 修改table样式：类似table、modal、form样式的定义不在instances这个目录下面，这个目录下定义的都是instances所特有的样式结构；table、modal、form这些样式的定义往往是全局的，基本都是放在themes/bruce/templates/horizon/common目录下面，例如：themes/bruce/templates/horizon/common/_data_xxx.html用来定义table的样式；themes/bruce/templates/horizon/common/_form_xxx.html定义form表单；themes/bruce/templates/horizon/common/_modal_xxx.html定义modal表单；定义弹出框；……其他模块的修改都是类似的，例如概况页面、云硬盘等。 ￼ 主题切换回default：￼￼ 对原来主题没有任何影响，不得不佩服OpenStack Horizon代码架构越来越好了， 好了OpenStack Horizon的主题开发就讲到这里，后续将推出更多这样的文章！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OpenStack Horizon 主题下载]]></title>
      <url>%2F2017%2F02%2F26%2F2017022602%2F</url>
      <content type="text"><![CDATA[一、写在前面这篇文章主要介绍基于OpenStack Mitaka Horizon版本开发的主题Bruce，整个主题开发基本没有修改Horizon原有的任何代码，所有的主题代码都在horizon/openstack_dashboard/themes/bruce目录中，一方面更好的兼容openstack horion以便后续版本升级，另一方面，方便大家学习。如果转载，请保留作者信息。邮箱地址：jpzhang.ht@gmail.com个人博客：https://jianpengzhang.github.ioCSDN博客：http://blog.csdn.net/u011521019主题下载地址：https://jianpengzhang.github.io/2017/02/26/2017022603/ 二、OpenStack Bruce 主题介绍####目录结构：horizon/openstack_dashboard/themes.├── bruce│ ├── static│ └── templates├── default│ ├── bootstrap│ └── horizon├── demo│ ├── help│ ├── html│ ├── javascripts│ ├── patches│ └── styles└── material ├── static └── templates bruce代码主题包存放在bruce目录中。static目录用来存放所有的静态文件包括CSS、JS等，templates目录存放所有的主题模版。这里不在具体详细的解释开发步骤， Bruce 主题介绍：1、系统登录界面 登录界面下方可以自由切换喜欢的背景图片 2、项目概况 ￼￼ 登录进来后项目概况页面，左侧导航通过OpenStack 机制自动加载出来， 可以根据用户个人习惯，通过单机按钮展开或者缩紧， 右侧齿轮样子的图标可以根据喜好西游配置主题颜色风格 页面主要显示项目可用配置的使用情况，以及最近的项目操作记录，当然，操作记录这块底层并没有实现，要实现的话简单的方式就是在API 包里面通过装饰器的方式往数据库记录用户操作* 可以自由在openstack 原生主题切换3、项目云主机列表￼￼这一块基本保持openstack 原有的样式风格，只不过增加了云主机的介绍相关的信息。4、云主机详情￼￼同样，保持原生样式结构，只不过对一些信息点进行了高粱处理，不过您们有时间可以对这块的内容进行重新排版，当前的样式比较浪费空间。5、项目云硬盘 6、项目镜像列表 7、系统概况 8、系统虚拟机管理器 其他模块页面基本相识，这里不再一一展开来讲，感兴趣的可以通过以下的方式下载学习。 9、静态模版样式包： ￼ 三、部署通过下的方式获取代码包，通过 python manage.py runserver 运行：vi horizon-bruce/horizon/openstack_dashboard/local/ local_settings.py12OPENSTACK_HOST=&quot;192.168.31.235&quot;OPENSTACK_KEYSTONE_URL=&quot;http://192.168.31.235:5000/v3&quot; 配置您的openstack 控制节点地址，以及keystone地址，如果在同一个节点上地址就是一样的。 重新生成静态文件到/stack 目录下sudo python manage.py collectstatic -c 运行时候提示输入 “yes” 压缩静态问价：sudo python manage.py compress 通过Apache运行：通过mv 命令备份原先的horizon包，然后把下载下来新的horizon包放到该位置上，修改如下： vi horizon-bruce/horizon/openstack_dashboard/local/ local_settings.py12OPENSTACK_HOST=&quot;192.168.31.235&quot;OPENSTACK_KEYSTONE_URL=&quot;http://192.168.31.235:5000/v3&quot; 配置您的openstack 控制节点地址，以及keystone地址，如果在同一个节点上地址就是一样的。 重新生成静态文件到/stack 目录下sudo python manage.py collectstatic -c 运行时候提示输入 “yes” 压缩静态问价：sudo python manage.py compress 修改apache配置：vi /etc/apache2/sites-available/horizon.conf 路径可能有所不一样，应为我这里是devstack起的apache。主要是将“/dashboard/”修改成“/”根目录“/dashboard/“ ＝》 “/project/“1234WSGIScriptAlias / /home/devstack.mitaka/horizon/openstack_dashboard/wsgi/django.wsgiAlias /media /home/devstack.mitaka/horizon/openstack_dashboard/staticAlias /static /home/devstack.mitaka/horizon/staticRedirectMatch &quot;^/$&quot; &quot;/project/&quot; 重启apache服务即可 四、下载您的小额赞助，鼓励作者写出更好的主题，让更多的OpenStack开发者、创业公司能够更专注底层虚拟化、存储、网络，不必在担心horizon的优化等。 基本版本下载：包括上述描述的所有界面功能，但不提供静态主题包，扫一扫下方二维码，完成支付，并把截图发送给QQ：3477447625，将获取百度云下载密码，百度云下载地址：链接: http://pan.baidu.com/s/1slR9lHr 完整版本下载：包括基础版所有界面功能，并附加一个静态完整主题包(horizon/openstack_dashboard/themes/demo)，方便您后续按照需求继续完善开发。扫一扫下方二维码，完成支付，并把截图发送给QQ：3477447625，将获取百度云下载密码，百度云下载地址：链接: http://pan.baidu.com/s/1pLTFhSR￼]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[以此为点，从新起航]]></title>
      <url>%2F2017%2F02%2F26%2F2017022601%2F</url>
      <content type="text"><![CDATA[以此为点，记录下点点滴滴]]></content>
    </entry>

    
  
  
</search>
